// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: rendezvous.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_rendezvous_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_rendezvous_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_rendezvous_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_rendezvous_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_rendezvous_2eproto;
class ClipboardEvent;
struct ClipboardEventDefaultTypeInternal;
extern ClipboardEventDefaultTypeInternal _ClipboardEvent_default_instance_;
class FileContent;
struct FileContentDefaultTypeInternal;
extern FileContentDefaultTypeInternal _FileContent_default_instance_;
class Heartbeat;
struct HeartbeatDefaultTypeInternal;
extern HeartbeatDefaultTypeInternal _Heartbeat_default_instance_;
class InpuVideoFrame;
struct InpuVideoFrameDefaultTypeInternal;
extern InpuVideoFrameDefaultTypeInternal _InpuVideoFrame_default_instance_;
class InputControlEvent;
struct InputControlEventDefaultTypeInternal;
extern InputControlEventDefaultTypeInternal _InputControlEvent_default_instance_;
class KeyboardEvent;
struct KeyboardEventDefaultTypeInternal;
extern KeyboardEventDefaultTypeInternal _KeyboardEvent_default_instance_;
class MouseEvent;
struct MouseEventDefaultTypeInternal;
extern MouseEventDefaultTypeInternal _MouseEvent_default_instance_;
class PunchHole;
struct PunchHoleDefaultTypeInternal;
extern PunchHoleDefaultTypeInternal _PunchHole_default_instance_;
class PunchHoleRequest;
struct PunchHoleRequestDefaultTypeInternal;
extern PunchHoleRequestDefaultTypeInternal _PunchHoleRequest_default_instance_;
class PunchHoleResponse;
struct PunchHoleResponseDefaultTypeInternal;
extern PunchHoleResponseDefaultTypeInternal _PunchHoleResponse_default_instance_;
class PunchHoleSent;
struct PunchHoleSentDefaultTypeInternal;
extern PunchHoleSentDefaultTypeInternal _PunchHoleSent_default_instance_;
class RegisterPeer;
struct RegisterPeerDefaultTypeInternal;
extern RegisterPeerDefaultTypeInternal _RegisterPeer_default_instance_;
class RegisterPeerResponse;
struct RegisterPeerResponseDefaultTypeInternal;
extern RegisterPeerResponseDefaultTypeInternal _RegisterPeerResponse_default_instance_;
class RendezvousMessage;
struct RendezvousMessageDefaultTypeInternal;
extern RendezvousMessageDefaultTypeInternal _RendezvousMessage_default_instance_;
class RequestRelay;
struct RequestRelayDefaultTypeInternal;
extern RequestRelayDefaultTypeInternal _RequestRelay_default_instance_;
class TextContent;
struct TextContentDefaultTypeInternal;
extern TextContentDefaultTypeInternal _TextContent_default_instance_;
class TouchEvent;
struct TouchEventDefaultTypeInternal;
extern TouchEventDefaultTypeInternal _TouchEvent_default_instance_;
class TouchPoint;
struct TouchPointDefaultTypeInternal;
extern TouchPointDefaultTypeInternal _TouchPoint_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::ClipboardEvent* Arena::CreateMaybeMessage<::ClipboardEvent>(Arena*);
template<> ::FileContent* Arena::CreateMaybeMessage<::FileContent>(Arena*);
template<> ::Heartbeat* Arena::CreateMaybeMessage<::Heartbeat>(Arena*);
template<> ::InpuVideoFrame* Arena::CreateMaybeMessage<::InpuVideoFrame>(Arena*);
template<> ::InputControlEvent* Arena::CreateMaybeMessage<::InputControlEvent>(Arena*);
template<> ::KeyboardEvent* Arena::CreateMaybeMessage<::KeyboardEvent>(Arena*);
template<> ::MouseEvent* Arena::CreateMaybeMessage<::MouseEvent>(Arena*);
template<> ::PunchHole* Arena::CreateMaybeMessage<::PunchHole>(Arena*);
template<> ::PunchHoleRequest* Arena::CreateMaybeMessage<::PunchHoleRequest>(Arena*);
template<> ::PunchHoleResponse* Arena::CreateMaybeMessage<::PunchHoleResponse>(Arena*);
template<> ::PunchHoleSent* Arena::CreateMaybeMessage<::PunchHoleSent>(Arena*);
template<> ::RegisterPeer* Arena::CreateMaybeMessage<::RegisterPeer>(Arena*);
template<> ::RegisterPeerResponse* Arena::CreateMaybeMessage<::RegisterPeerResponse>(Arena*);
template<> ::RendezvousMessage* Arena::CreateMaybeMessage<::RendezvousMessage>(Arena*);
template<> ::RequestRelay* Arena::CreateMaybeMessage<::RequestRelay>(Arena*);
template<> ::TextContent* Arena::CreateMaybeMessage<::TextContent>(Arena*);
template<> ::TouchEvent* Arena::CreateMaybeMessage<::TouchEvent>(Arena*);
template<> ::TouchPoint* Arena::CreateMaybeMessage<::TouchPoint>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

enum RequestRelay_DeskRole : int {
  RequestRelay_DeskRole_DESK_CONTROL = 0,
  RequestRelay_DeskRole_DESK_SERVER = 1,
  RequestRelay_DeskRole_RequestRelay_DeskRole_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  RequestRelay_DeskRole_RequestRelay_DeskRole_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool RequestRelay_DeskRole_IsValid(int value);
constexpr RequestRelay_DeskRole RequestRelay_DeskRole_DeskRole_MIN = RequestRelay_DeskRole_DESK_CONTROL;
constexpr RequestRelay_DeskRole RequestRelay_DeskRole_DeskRole_MAX = RequestRelay_DeskRole_DESK_SERVER;
constexpr int RequestRelay_DeskRole_DeskRole_ARRAYSIZE = RequestRelay_DeskRole_DeskRole_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RequestRelay_DeskRole_descriptor();
template<typename T>
inline const std::string& RequestRelay_DeskRole_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RequestRelay_DeskRole>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RequestRelay_DeskRole_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RequestRelay_DeskRole_descriptor(), enum_t_value);
}
inline bool RequestRelay_DeskRole_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RequestRelay_DeskRole* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RequestRelay_DeskRole>(
    RequestRelay_DeskRole_descriptor(), name, value);
}
enum TouchPoint_TouchPhase : int {
  TouchPoint_TouchPhase_TOUCH_BEGIN = 0,
  TouchPoint_TouchPhase_TOUCH_MOVE = 1,
  TouchPoint_TouchPhase_TOUCH_END = 2,
  TouchPoint_TouchPhase_TOUCH_CANCEL = 3,
  TouchPoint_TouchPhase_TouchPoint_TouchPhase_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  TouchPoint_TouchPhase_TouchPoint_TouchPhase_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool TouchPoint_TouchPhase_IsValid(int value);
constexpr TouchPoint_TouchPhase TouchPoint_TouchPhase_TouchPhase_MIN = TouchPoint_TouchPhase_TOUCH_BEGIN;
constexpr TouchPoint_TouchPhase TouchPoint_TouchPhase_TouchPhase_MAX = TouchPoint_TouchPhase_TOUCH_CANCEL;
constexpr int TouchPoint_TouchPhase_TouchPhase_ARRAYSIZE = TouchPoint_TouchPhase_TouchPhase_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TouchPoint_TouchPhase_descriptor();
template<typename T>
inline const std::string& TouchPoint_TouchPhase_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TouchPoint_TouchPhase>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TouchPoint_TouchPhase_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TouchPoint_TouchPhase_descriptor(), enum_t_value);
}
inline bool TouchPoint_TouchPhase_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TouchPoint_TouchPhase* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TouchPoint_TouchPhase>(
    TouchPoint_TouchPhase_descriptor(), name, value);
}
enum Result : int {
  OK = 0,
  ID_NOT_EXIST = 1,
  DESKSERVER_OFFLINE = 2,
  RELAYSERVER_OFFLINE = 3,
  INNER_ERROR = 4,
  Result_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Result_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Result_IsValid(int value);
constexpr Result Result_MIN = OK;
constexpr Result Result_MAX = INNER_ERROR;
constexpr int Result_ARRAYSIZE = Result_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Result_descriptor();
template<typename T>
inline const std::string& Result_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Result>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Result_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Result_descriptor(), enum_t_value);
}
inline bool Result_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Result* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Result>(
    Result_descriptor(), name, value);
}
// ===================================================================

class RequestRelay final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RequestRelay) */ {
 public:
  inline RequestRelay() : RequestRelay(nullptr) {}
  ~RequestRelay() override;
  explicit PROTOBUF_CONSTEXPR RequestRelay(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestRelay(const RequestRelay& from);
  RequestRelay(RequestRelay&& from) noexcept
    : RequestRelay() {
    *this = ::std::move(from);
  }

  inline RequestRelay& operator=(const RequestRelay& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestRelay& operator=(RequestRelay&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestRelay& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestRelay* internal_default_instance() {
    return reinterpret_cast<const RequestRelay*>(
               &_RequestRelay_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(RequestRelay& a, RequestRelay& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestRelay* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestRelay* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestRelay* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestRelay>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequestRelay& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RequestRelay& from) {
    RequestRelay::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestRelay* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RequestRelay";
  }
  protected:
  explicit RequestRelay(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef RequestRelay_DeskRole DeskRole;
  static constexpr DeskRole DESK_CONTROL =
    RequestRelay_DeskRole_DESK_CONTROL;
  static constexpr DeskRole DESK_SERVER =
    RequestRelay_DeskRole_DESK_SERVER;
  static inline bool DeskRole_IsValid(int value) {
    return RequestRelay_DeskRole_IsValid(value);
  }
  static constexpr DeskRole DeskRole_MIN =
    RequestRelay_DeskRole_DeskRole_MIN;
  static constexpr DeskRole DeskRole_MAX =
    RequestRelay_DeskRole_DeskRole_MAX;
  static constexpr int DeskRole_ARRAYSIZE =
    RequestRelay_DeskRole_DeskRole_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  DeskRole_descriptor() {
    return RequestRelay_DeskRole_descriptor();
  }
  template<typename T>
  static inline const std::string& DeskRole_Name(T enum_t_value) {
    static_assert(::std::is_same<T, DeskRole>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function DeskRole_Name.");
    return RequestRelay_DeskRole_Name(enum_t_value);
  }
  static inline bool DeskRole_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      DeskRole* value) {
    return RequestRelay_DeskRole_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kUuidFieldNumber = 1,
    kRoleFieldNumber = 2,
  };
  // string uuid = 1;
  void clear_uuid();
  const std::string& uuid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uuid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uuid();
  PROTOBUF_NODISCARD std::string* release_uuid();
  void set_allocated_uuid(std::string* uuid);
  private:
  const std::string& _internal_uuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uuid(const std::string& value);
  std::string* _internal_mutable_uuid();
  public:

  // .RequestRelay.DeskRole role = 2;
  void clear_role();
  ::RequestRelay_DeskRole role() const;
  void set_role(::RequestRelay_DeskRole value);
  private:
  ::RequestRelay_DeskRole _internal_role() const;
  void _internal_set_role(::RequestRelay_DeskRole value);
  public:

  // @@protoc_insertion_point(class_scope:RequestRelay)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uuid_;
    int role_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rendezvous_2eproto;
};
// -------------------------------------------------------------------

class RegisterPeer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RegisterPeer) */ {
 public:
  inline RegisterPeer() : RegisterPeer(nullptr) {}
  ~RegisterPeer() override;
  explicit PROTOBUF_CONSTEXPR RegisterPeer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegisterPeer(const RegisterPeer& from);
  RegisterPeer(RegisterPeer&& from) noexcept
    : RegisterPeer() {
    *this = ::std::move(from);
  }

  inline RegisterPeer& operator=(const RegisterPeer& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterPeer& operator=(RegisterPeer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegisterPeer& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegisterPeer* internal_default_instance() {
    return reinterpret_cast<const RegisterPeer*>(
               &_RegisterPeer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(RegisterPeer& a, RegisterPeer& b) {
    a.Swap(&b);
  }
  inline void Swap(RegisterPeer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterPeer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegisterPeer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegisterPeer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegisterPeer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RegisterPeer& from) {
    RegisterPeer::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterPeer* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RegisterPeer";
  }
  protected:
  explicit RegisterPeer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUuidFieldNumber = 1,
  };
  // bytes uuid = 1;
  void clear_uuid();
  const std::string& uuid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uuid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uuid();
  PROTOBUF_NODISCARD std::string* release_uuid();
  void set_allocated_uuid(std::string* uuid);
  private:
  const std::string& _internal_uuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uuid(const std::string& value);
  std::string* _internal_mutable_uuid();
  public:

  // @@protoc_insertion_point(class_scope:RegisterPeer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uuid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rendezvous_2eproto;
};
// -------------------------------------------------------------------

class RegisterPeerResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RegisterPeerResponse) */ {
 public:
  inline RegisterPeerResponse() : RegisterPeerResponse(nullptr) {}
  ~RegisterPeerResponse() override;
  explicit PROTOBUF_CONSTEXPR RegisterPeerResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegisterPeerResponse(const RegisterPeerResponse& from);
  RegisterPeerResponse(RegisterPeerResponse&& from) noexcept
    : RegisterPeerResponse() {
    *this = ::std::move(from);
  }

  inline RegisterPeerResponse& operator=(const RegisterPeerResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterPeerResponse& operator=(RegisterPeerResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegisterPeerResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegisterPeerResponse* internal_default_instance() {
    return reinterpret_cast<const RegisterPeerResponse*>(
               &_RegisterPeerResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(RegisterPeerResponse& a, RegisterPeerResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RegisterPeerResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterPeerResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegisterPeerResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegisterPeerResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegisterPeerResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RegisterPeerResponse& from) {
    RegisterPeerResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterPeerResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RegisterPeerResponse";
  }
  protected:
  explicit RegisterPeerResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
  };
  // .Result result = 1;
  void clear_result();
  ::Result result() const;
  void set_result(::Result value);
  private:
  ::Result _internal_result() const;
  void _internal_set_result(::Result value);
  public:

  // @@protoc_insertion_point(class_scope:RegisterPeerResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int result_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rendezvous_2eproto;
};
// -------------------------------------------------------------------

class PunchHoleRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PunchHoleRequest) */ {
 public:
  inline PunchHoleRequest() : PunchHoleRequest(nullptr) {}
  ~PunchHoleRequest() override;
  explicit PROTOBUF_CONSTEXPR PunchHoleRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PunchHoleRequest(const PunchHoleRequest& from);
  PunchHoleRequest(PunchHoleRequest&& from) noexcept
    : PunchHoleRequest() {
    *this = ::std::move(from);
  }

  inline PunchHoleRequest& operator=(const PunchHoleRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PunchHoleRequest& operator=(PunchHoleRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PunchHoleRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PunchHoleRequest* internal_default_instance() {
    return reinterpret_cast<const PunchHoleRequest*>(
               &_PunchHoleRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(PunchHoleRequest& a, PunchHoleRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PunchHoleRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PunchHoleRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PunchHoleRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PunchHoleRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PunchHoleRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PunchHoleRequest& from) {
    PunchHoleRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PunchHoleRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PunchHoleRequest";
  }
  protected:
  explicit PunchHoleRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUuidFieldNumber = 1,
    kIdFieldNumber = 2,
  };
  // bytes uuid = 1;
  void clear_uuid();
  const std::string& uuid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uuid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uuid();
  PROTOBUF_NODISCARD std::string* release_uuid();
  void set_allocated_uuid(std::string* uuid);
  private:
  const std::string& _internal_uuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uuid(const std::string& value);
  std::string* _internal_mutable_uuid();
  public:

  // bytes id = 2;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:PunchHoleRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uuid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rendezvous_2eproto;
};
// -------------------------------------------------------------------

class PunchHoleResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PunchHoleResponse) */ {
 public:
  inline PunchHoleResponse() : PunchHoleResponse(nullptr) {}
  ~PunchHoleResponse() override;
  explicit PROTOBUF_CONSTEXPR PunchHoleResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PunchHoleResponse(const PunchHoleResponse& from);
  PunchHoleResponse(PunchHoleResponse&& from) noexcept
    : PunchHoleResponse() {
    *this = ::std::move(from);
  }

  inline PunchHoleResponse& operator=(const PunchHoleResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PunchHoleResponse& operator=(PunchHoleResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PunchHoleResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const PunchHoleResponse* internal_default_instance() {
    return reinterpret_cast<const PunchHoleResponse*>(
               &_PunchHoleResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(PunchHoleResponse& a, PunchHoleResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(PunchHoleResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PunchHoleResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PunchHoleResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PunchHoleResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PunchHoleResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PunchHoleResponse& from) {
    PunchHoleResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PunchHoleResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PunchHoleResponse";
  }
  protected:
  explicit PunchHoleResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRelayServerFieldNumber = 1,
    kRelayPortFieldNumber = 2,
    kResultFieldNumber = 3,
  };
  // string relay_server = 1;
  void clear_relay_server();
  const std::string& relay_server() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_relay_server(ArgT0&& arg0, ArgT... args);
  std::string* mutable_relay_server();
  PROTOBUF_NODISCARD std::string* release_relay_server();
  void set_allocated_relay_server(std::string* relay_server);
  private:
  const std::string& _internal_relay_server() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_relay_server(const std::string& value);
  std::string* _internal_mutable_relay_server();
  public:

  // int32 relay_port = 2;
  void clear_relay_port();
  int32_t relay_port() const;
  void set_relay_port(int32_t value);
  private:
  int32_t _internal_relay_port() const;
  void _internal_set_relay_port(int32_t value);
  public:

  // .Result result = 3;
  void clear_result();
  ::Result result() const;
  void set_result(::Result value);
  private:
  ::Result _internal_result() const;
  void _internal_set_result(::Result value);
  public:

  // @@protoc_insertion_point(class_scope:PunchHoleResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr relay_server_;
    int32_t relay_port_;
    int result_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rendezvous_2eproto;
};
// -------------------------------------------------------------------

class Heartbeat final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:Heartbeat) */ {
 public:
  inline Heartbeat() : Heartbeat(nullptr) {}
  explicit PROTOBUF_CONSTEXPR Heartbeat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Heartbeat(const Heartbeat& from);
  Heartbeat(Heartbeat&& from) noexcept
    : Heartbeat() {
    *this = ::std::move(from);
  }

  inline Heartbeat& operator=(const Heartbeat& from) {
    CopyFrom(from);
    return *this;
  }
  inline Heartbeat& operator=(Heartbeat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Heartbeat& default_instance() {
    return *internal_default_instance();
  }
  static inline const Heartbeat* internal_default_instance() {
    return reinterpret_cast<const Heartbeat*>(
               &_Heartbeat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Heartbeat& a, Heartbeat& b) {
    a.Swap(&b);
  }
  inline void Swap(Heartbeat* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Heartbeat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Heartbeat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Heartbeat>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Heartbeat& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Heartbeat& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Heartbeat";
  }
  protected:
  explicit Heartbeat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Heartbeat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_rendezvous_2eproto;
};
// -------------------------------------------------------------------

class PunchHole final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PunchHole) */ {
 public:
  inline PunchHole() : PunchHole(nullptr) {}
  ~PunchHole() override;
  explicit PROTOBUF_CONSTEXPR PunchHole(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PunchHole(const PunchHole& from);
  PunchHole(PunchHole&& from) noexcept
    : PunchHole() {
    *this = ::std::move(from);
  }

  inline PunchHole& operator=(const PunchHole& from) {
    CopyFrom(from);
    return *this;
  }
  inline PunchHole& operator=(PunchHole&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PunchHole& default_instance() {
    return *internal_default_instance();
  }
  static inline const PunchHole* internal_default_instance() {
    return reinterpret_cast<const PunchHole*>(
               &_PunchHole_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(PunchHole& a, PunchHole& b) {
    a.Swap(&b);
  }
  inline void Swap(PunchHole* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PunchHole* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PunchHole* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PunchHole>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PunchHole& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PunchHole& from) {
    PunchHole::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PunchHole* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PunchHole";
  }
  protected:
  explicit PunchHole(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // bytes id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:PunchHole)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rendezvous_2eproto;
};
// -------------------------------------------------------------------

class PunchHoleSent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:PunchHoleSent) */ {
 public:
  inline PunchHoleSent() : PunchHoleSent(nullptr) {}
  ~PunchHoleSent() override;
  explicit PROTOBUF_CONSTEXPR PunchHoleSent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PunchHoleSent(const PunchHoleSent& from);
  PunchHoleSent(PunchHoleSent&& from) noexcept
    : PunchHoleSent() {
    *this = ::std::move(from);
  }

  inline PunchHoleSent& operator=(const PunchHoleSent& from) {
    CopyFrom(from);
    return *this;
  }
  inline PunchHoleSent& operator=(PunchHoleSent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PunchHoleSent& default_instance() {
    return *internal_default_instance();
  }
  static inline const PunchHoleSent* internal_default_instance() {
    return reinterpret_cast<const PunchHoleSent*>(
               &_PunchHoleSent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(PunchHoleSent& a, PunchHoleSent& b) {
    a.Swap(&b);
  }
  inline void Swap(PunchHoleSent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PunchHoleSent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PunchHoleSent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PunchHoleSent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PunchHoleSent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PunchHoleSent& from) {
    PunchHoleSent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PunchHoleSent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "PunchHoleSent";
  }
  protected:
  explicit PunchHoleSent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRelayServerFieldNumber = 1,
    kIdFieldNumber = 4,
    kRelayPortFieldNumber = 2,
    kResultFieldNumber = 3,
  };
  // string relay_server = 1;
  void clear_relay_server();
  const std::string& relay_server() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_relay_server(ArgT0&& arg0, ArgT... args);
  std::string* mutable_relay_server();
  PROTOBUF_NODISCARD std::string* release_relay_server();
  void set_allocated_relay_server(std::string* relay_server);
  private:
  const std::string& _internal_relay_server() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_relay_server(const std::string& value);
  std::string* _internal_mutable_relay_server();
  public:

  // bytes id = 4;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // int32 relay_port = 2;
  void clear_relay_port();
  int32_t relay_port() const;
  void set_relay_port(int32_t value);
  private:
  int32_t _internal_relay_port() const;
  void _internal_set_relay_port(int32_t value);
  public:

  // .Result result = 3;
  void clear_result();
  ::Result result() const;
  void set_result(::Result value);
  private:
  ::Result _internal_result() const;
  void _internal_set_result(::Result value);
  public:

  // @@protoc_insertion_point(class_scope:PunchHoleSent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr relay_server_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    int32_t relay_port_;
    int result_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rendezvous_2eproto;
};
// -------------------------------------------------------------------

class InputControlEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:InputControlEvent) */ {
 public:
  inline InputControlEvent() : InputControlEvent(nullptr) {}
  ~InputControlEvent() override;
  explicit PROTOBUF_CONSTEXPR InputControlEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InputControlEvent(const InputControlEvent& from);
  InputControlEvent(InputControlEvent&& from) noexcept
    : InputControlEvent() {
    *this = ::std::move(from);
  }

  inline InputControlEvent& operator=(const InputControlEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline InputControlEvent& operator=(InputControlEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InputControlEvent& default_instance() {
    return *internal_default_instance();
  }
  enum EventCase {
    kMouseEvent = 1,
    kKeyboardEvent = 2,
    kTouchEvent = 3,
    EVENT_NOT_SET = 0,
  };

  static inline const InputControlEvent* internal_default_instance() {
    return reinterpret_cast<const InputControlEvent*>(
               &_InputControlEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(InputControlEvent& a, InputControlEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(InputControlEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InputControlEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InputControlEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InputControlEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InputControlEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InputControlEvent& from) {
    InputControlEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InputControlEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "InputControlEvent";
  }
  protected:
  explicit InputControlEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMouseEventFieldNumber = 1,
    kKeyboardEventFieldNumber = 2,
    kTouchEventFieldNumber = 3,
  };
  // .MouseEvent mouse_event = 1;
  bool has_mouse_event() const;
  private:
  bool _internal_has_mouse_event() const;
  public:
  void clear_mouse_event();
  const ::MouseEvent& mouse_event() const;
  PROTOBUF_NODISCARD ::MouseEvent* release_mouse_event();
  ::MouseEvent* mutable_mouse_event();
  void set_allocated_mouse_event(::MouseEvent* mouse_event);
  private:
  const ::MouseEvent& _internal_mouse_event() const;
  ::MouseEvent* _internal_mutable_mouse_event();
  public:
  void unsafe_arena_set_allocated_mouse_event(
      ::MouseEvent* mouse_event);
  ::MouseEvent* unsafe_arena_release_mouse_event();

  // .KeyboardEvent keyboard_event = 2;
  bool has_keyboard_event() const;
  private:
  bool _internal_has_keyboard_event() const;
  public:
  void clear_keyboard_event();
  const ::KeyboardEvent& keyboard_event() const;
  PROTOBUF_NODISCARD ::KeyboardEvent* release_keyboard_event();
  ::KeyboardEvent* mutable_keyboard_event();
  void set_allocated_keyboard_event(::KeyboardEvent* keyboard_event);
  private:
  const ::KeyboardEvent& _internal_keyboard_event() const;
  ::KeyboardEvent* _internal_mutable_keyboard_event();
  public:
  void unsafe_arena_set_allocated_keyboard_event(
      ::KeyboardEvent* keyboard_event);
  ::KeyboardEvent* unsafe_arena_release_keyboard_event();

  // .TouchEvent touch_event = 3;
  bool has_touch_event() const;
  private:
  bool _internal_has_touch_event() const;
  public:
  void clear_touch_event();
  const ::TouchEvent& touch_event() const;
  PROTOBUF_NODISCARD ::TouchEvent* release_touch_event();
  ::TouchEvent* mutable_touch_event();
  void set_allocated_touch_event(::TouchEvent* touch_event);
  private:
  const ::TouchEvent& _internal_touch_event() const;
  ::TouchEvent* _internal_mutable_touch_event();
  public:
  void unsafe_arena_set_allocated_touch_event(
      ::TouchEvent* touch_event);
  ::TouchEvent* unsafe_arena_release_touch_event();

  void clear_event();
  EventCase event_case() const;
  // @@protoc_insertion_point(class_scope:InputControlEvent)
 private:
  class _Internal;
  void set_has_mouse_event();
  void set_has_keyboard_event();
  void set_has_touch_event();

  inline bool has_event() const;
  inline void clear_has_event();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union EventUnion {
      constexpr EventUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::MouseEvent* mouse_event_;
      ::KeyboardEvent* keyboard_event_;
      ::TouchEvent* touch_event_;
    } event_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rendezvous_2eproto;
};
// -------------------------------------------------------------------

class ClipboardEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ClipboardEvent) */ {
 public:
  inline ClipboardEvent() : ClipboardEvent(nullptr) {}
  ~ClipboardEvent() override;
  explicit PROTOBUF_CONSTEXPR ClipboardEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClipboardEvent(const ClipboardEvent& from);
  ClipboardEvent(ClipboardEvent&& from) noexcept
    : ClipboardEvent() {
    *this = ::std::move(from);
  }

  inline ClipboardEvent& operator=(const ClipboardEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClipboardEvent& operator=(ClipboardEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClipboardEvent& default_instance() {
    return *internal_default_instance();
  }
  enum EventCase {
    kText = 1,
    kFile = 2,
    EVENT_NOT_SET = 0,
  };

  static inline const ClipboardEvent* internal_default_instance() {
    return reinterpret_cast<const ClipboardEvent*>(
               &_ClipboardEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ClipboardEvent& a, ClipboardEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(ClipboardEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClipboardEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClipboardEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClipboardEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ClipboardEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ClipboardEvent& from) {
    ClipboardEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClipboardEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ClipboardEvent";
  }
  protected:
  explicit ClipboardEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTextFieldNumber = 1,
    kFileFieldNumber = 2,
  };
  // .TextContent text = 1;
  bool has_text() const;
  private:
  bool _internal_has_text() const;
  public:
  void clear_text();
  const ::TextContent& text() const;
  PROTOBUF_NODISCARD ::TextContent* release_text();
  ::TextContent* mutable_text();
  void set_allocated_text(::TextContent* text);
  private:
  const ::TextContent& _internal_text() const;
  ::TextContent* _internal_mutable_text();
  public:
  void unsafe_arena_set_allocated_text(
      ::TextContent* text);
  ::TextContent* unsafe_arena_release_text();

  // .FileContent file = 2;
  bool has_file() const;
  private:
  bool _internal_has_file() const;
  public:
  void clear_file();
  const ::FileContent& file() const;
  PROTOBUF_NODISCARD ::FileContent* release_file();
  ::FileContent* mutable_file();
  void set_allocated_file(::FileContent* file);
  private:
  const ::FileContent& _internal_file() const;
  ::FileContent* _internal_mutable_file();
  public:
  void unsafe_arena_set_allocated_file(
      ::FileContent* file);
  ::FileContent* unsafe_arena_release_file();

  void clear_event();
  EventCase event_case() const;
  // @@protoc_insertion_point(class_scope:ClipboardEvent)
 private:
  class _Internal;
  void set_has_text();
  void set_has_file();

  inline bool has_event() const;
  inline void clear_has_event();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union EventUnion {
      constexpr EventUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::TextContent* text_;
      ::FileContent* file_;
    } event_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rendezvous_2eproto;
};
// -------------------------------------------------------------------

class TextContent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TextContent) */ {
 public:
  inline TextContent() : TextContent(nullptr) {}
  ~TextContent() override;
  explicit PROTOBUF_CONSTEXPR TextContent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TextContent(const TextContent& from);
  TextContent(TextContent&& from) noexcept
    : TextContent() {
    *this = ::std::move(from);
  }

  inline TextContent& operator=(const TextContent& from) {
    CopyFrom(from);
    return *this;
  }
  inline TextContent& operator=(TextContent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TextContent& default_instance() {
    return *internal_default_instance();
  }
  static inline const TextContent* internal_default_instance() {
    return reinterpret_cast<const TextContent*>(
               &_TextContent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(TextContent& a, TextContent& b) {
    a.Swap(&b);
  }
  inline void Swap(TextContent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TextContent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TextContent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TextContent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TextContent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TextContent& from) {
    TextContent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TextContent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TextContent";
  }
  protected:
  explicit TextContent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTextDataFieldNumber = 1,
  };
  // string text_data = 1;
  void clear_text_data();
  const std::string& text_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text_data();
  PROTOBUF_NODISCARD std::string* release_text_data();
  void set_allocated_text_data(std::string* text_data);
  private:
  const std::string& _internal_text_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text_data(const std::string& value);
  std::string* _internal_mutable_text_data();
  public:

  // @@protoc_insertion_point(class_scope:TextContent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rendezvous_2eproto;
};
// -------------------------------------------------------------------

class FileContent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:FileContent) */ {
 public:
  inline FileContent() : FileContent(nullptr) {}
  ~FileContent() override;
  explicit PROTOBUF_CONSTEXPR FileContent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FileContent(const FileContent& from);
  FileContent(FileContent&& from) noexcept
    : FileContent() {
    *this = ::std::move(from);
  }

  inline FileContent& operator=(const FileContent& from) {
    CopyFrom(from);
    return *this;
  }
  inline FileContent& operator=(FileContent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FileContent& default_instance() {
    return *internal_default_instance();
  }
  static inline const FileContent* internal_default_instance() {
    return reinterpret_cast<const FileContent*>(
               &_FileContent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(FileContent& a, FileContent& b) {
    a.Swap(&b);
  }
  inline void Swap(FileContent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FileContent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FileContent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FileContent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FileContent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FileContent& from) {
    FileContent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FileContent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "FileContent";
  }
  protected:
  explicit FileContent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFileDataFieldNumber = 1,
    kFileNameFieldNumber = 2,
  };
  // bytes file_data = 1;
  void clear_file_data();
  const std::string& file_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_file_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_file_data();
  PROTOBUF_NODISCARD std::string* release_file_data();
  void set_allocated_file_data(std::string* file_data);
  private:
  const std::string& _internal_file_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_data(const std::string& value);
  std::string* _internal_mutable_file_data();
  public:

  // string file_name = 2;
  void clear_file_name();
  const std::string& file_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_file_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_file_name();
  PROTOBUF_NODISCARD std::string* release_file_name();
  void set_allocated_file_name(std::string* file_name);
  private:
  const std::string& _internal_file_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_name(const std::string& value);
  std::string* _internal_mutable_file_name();
  public:

  // @@protoc_insertion_point(class_scope:FileContent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_data_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rendezvous_2eproto;
};
// -------------------------------------------------------------------

class InpuVideoFrame final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:InpuVideoFrame) */ {
 public:
  inline InpuVideoFrame() : InpuVideoFrame(nullptr) {}
  ~InpuVideoFrame() override;
  explicit PROTOBUF_CONSTEXPR InpuVideoFrame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InpuVideoFrame(const InpuVideoFrame& from);
  InpuVideoFrame(InpuVideoFrame&& from) noexcept
    : InpuVideoFrame() {
    *this = ::std::move(from);
  }

  inline InpuVideoFrame& operator=(const InpuVideoFrame& from) {
    CopyFrom(from);
    return *this;
  }
  inline InpuVideoFrame& operator=(InpuVideoFrame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InpuVideoFrame& default_instance() {
    return *internal_default_instance();
  }
  static inline const InpuVideoFrame* internal_default_instance() {
    return reinterpret_cast<const InpuVideoFrame*>(
               &_InpuVideoFrame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(InpuVideoFrame& a, InpuVideoFrame& b) {
    a.Swap(&b);
  }
  inline void Swap(InpuVideoFrame* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InpuVideoFrame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InpuVideoFrame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InpuVideoFrame>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InpuVideoFrame& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InpuVideoFrame& from) {
    InpuVideoFrame::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InpuVideoFrame* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "InpuVideoFrame";
  }
  protected:
  explicit InpuVideoFrame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
  };
  // bytes data = 1;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // @@protoc_insertion_point(class_scope:InpuVideoFrame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rendezvous_2eproto;
};
// -------------------------------------------------------------------

class MouseEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MouseEvent) */ {
 public:
  inline MouseEvent() : MouseEvent(nullptr) {}
  ~MouseEvent() override;
  explicit PROTOBUF_CONSTEXPR MouseEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MouseEvent(const MouseEvent& from);
  MouseEvent(MouseEvent&& from) noexcept
    : MouseEvent() {
    *this = ::std::move(from);
  }

  inline MouseEvent& operator=(const MouseEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline MouseEvent& operator=(MouseEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MouseEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const MouseEvent* internal_default_instance() {
    return reinterpret_cast<const MouseEvent*>(
               &_MouseEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(MouseEvent& a, MouseEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(MouseEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MouseEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MouseEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MouseEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MouseEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MouseEvent& from) {
    MouseEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MouseEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MouseEvent";
  }
  protected:
  explicit MouseEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModifiersFieldNumber = 5,
    kMaskFieldNumber = 1,
    kXFieldNumber = 2,
    kYFieldNumber = 3,
    kValueFieldNumber = 4,
  };
  // repeated int32 modifiers = 5;
  int modifiers_size() const;
  private:
  int _internal_modifiers_size() const;
  public:
  void clear_modifiers();
  private:
  int32_t _internal_modifiers(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_modifiers() const;
  void _internal_add_modifiers(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_modifiers();
  public:
  int32_t modifiers(int index) const;
  void set_modifiers(int index, int32_t value);
  void add_modifiers(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      modifiers() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_modifiers();

  // int32 mask = 1;
  void clear_mask();
  int32_t mask() const;
  void set_mask(int32_t value);
  private:
  int32_t _internal_mask() const;
  void _internal_set_mask(int32_t value);
  public:

  // sint32 x = 2;
  void clear_x();
  int32_t x() const;
  void set_x(int32_t value);
  private:
  int32_t _internal_x() const;
  void _internal_set_x(int32_t value);
  public:

  // sint32 y = 3;
  void clear_y();
  int32_t y() const;
  void set_y(int32_t value);
  private:
  int32_t _internal_y() const;
  void _internal_set_y(int32_t value);
  public:

  // sint32 value = 4;
  void clear_value();
  int32_t value() const;
  void set_value(int32_t value);
  private:
  int32_t _internal_value() const;
  void _internal_set_value(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:MouseEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > modifiers_;
    mutable std::atomic<int> _modifiers_cached_byte_size_;
    int32_t mask_;
    int32_t x_;
    int32_t y_;
    int32_t value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rendezvous_2eproto;
};
// -------------------------------------------------------------------

class KeyboardEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:KeyboardEvent) */ {
 public:
  inline KeyboardEvent() : KeyboardEvent(nullptr) {}
  ~KeyboardEvent() override;
  explicit PROTOBUF_CONSTEXPR KeyboardEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KeyboardEvent(const KeyboardEvent& from);
  KeyboardEvent(KeyboardEvent&& from) noexcept
    : KeyboardEvent() {
    *this = ::std::move(from);
  }

  inline KeyboardEvent& operator=(const KeyboardEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline KeyboardEvent& operator=(KeyboardEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KeyboardEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const KeyboardEvent* internal_default_instance() {
    return reinterpret_cast<const KeyboardEvent*>(
               &_KeyboardEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(KeyboardEvent& a, KeyboardEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(KeyboardEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KeyboardEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KeyboardEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<KeyboardEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const KeyboardEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const KeyboardEvent& from) {
    KeyboardEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KeyboardEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "KeyboardEvent";
  }
  protected:
  explicit KeyboardEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 2,
    kPressedFieldNumber = 3,
  };
  // int32 key = 2;
  void clear_key();
  int32_t key() const;
  void set_key(int32_t value);
  private:
  int32_t _internal_key() const;
  void _internal_set_key(int32_t value);
  public:

  // bool pressed = 3;
  void clear_pressed();
  bool pressed() const;
  void set_pressed(bool value);
  private:
  bool _internal_pressed() const;
  void _internal_set_pressed(bool value);
  public:

  // @@protoc_insertion_point(class_scope:KeyboardEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t key_;
    bool pressed_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rendezvous_2eproto;
};
// -------------------------------------------------------------------

class TouchPoint final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TouchPoint) */ {
 public:
  inline TouchPoint() : TouchPoint(nullptr) {}
  ~TouchPoint() override;
  explicit PROTOBUF_CONSTEXPR TouchPoint(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TouchPoint(const TouchPoint& from);
  TouchPoint(TouchPoint&& from) noexcept
    : TouchPoint() {
    *this = ::std::move(from);
  }

  inline TouchPoint& operator=(const TouchPoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline TouchPoint& operator=(TouchPoint&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TouchPoint& default_instance() {
    return *internal_default_instance();
  }
  static inline const TouchPoint* internal_default_instance() {
    return reinterpret_cast<const TouchPoint*>(
               &_TouchPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(TouchPoint& a, TouchPoint& b) {
    a.Swap(&b);
  }
  inline void Swap(TouchPoint* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TouchPoint* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TouchPoint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TouchPoint>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TouchPoint& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TouchPoint& from) {
    TouchPoint::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TouchPoint* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TouchPoint";
  }
  protected:
  explicit TouchPoint(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TouchPoint_TouchPhase TouchPhase;
  static constexpr TouchPhase TOUCH_BEGIN =
    TouchPoint_TouchPhase_TOUCH_BEGIN;
  static constexpr TouchPhase TOUCH_MOVE =
    TouchPoint_TouchPhase_TOUCH_MOVE;
  static constexpr TouchPhase TOUCH_END =
    TouchPoint_TouchPhase_TOUCH_END;
  static constexpr TouchPhase TOUCH_CANCEL =
    TouchPoint_TouchPhase_TOUCH_CANCEL;
  static inline bool TouchPhase_IsValid(int value) {
    return TouchPoint_TouchPhase_IsValid(value);
  }
  static constexpr TouchPhase TouchPhase_MIN =
    TouchPoint_TouchPhase_TouchPhase_MIN;
  static constexpr TouchPhase TouchPhase_MAX =
    TouchPoint_TouchPhase_TouchPhase_MAX;
  static constexpr int TouchPhase_ARRAYSIZE =
    TouchPoint_TouchPhase_TouchPhase_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  TouchPhase_descriptor() {
    return TouchPoint_TouchPhase_descriptor();
  }
  template<typename T>
  static inline const std::string& TouchPhase_Name(T enum_t_value) {
    static_assert(::std::is_same<T, TouchPhase>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function TouchPhase_Name.");
    return TouchPoint_TouchPhase_Name(enum_t_value);
  }
  static inline bool TouchPhase_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      TouchPhase* value) {
    return TouchPoint_TouchPhase_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kXFieldNumber = 2,
    kYFieldNumber = 3,
    kPhaseFieldNumber = 4,
    kPressureFieldNumber = 5,
    kSizeFieldNumber = 6,
  };
  // int32 id = 1;
  void clear_id();
  int32_t id() const;
  void set_id(int32_t value);
  private:
  int32_t _internal_id() const;
  void _internal_set_id(int32_t value);
  public:

  // sint32 x = 2;
  void clear_x();
  int32_t x() const;
  void set_x(int32_t value);
  private:
  int32_t _internal_x() const;
  void _internal_set_x(int32_t value);
  public:

  // sint32 y = 3;
  void clear_y();
  int32_t y() const;
  void set_y(int32_t value);
  private:
  int32_t _internal_y() const;
  void _internal_set_y(int32_t value);
  public:

  // .TouchPoint.TouchPhase phase = 4;
  void clear_phase();
  ::TouchPoint_TouchPhase phase() const;
  void set_phase(::TouchPoint_TouchPhase value);
  private:
  ::TouchPoint_TouchPhase _internal_phase() const;
  void _internal_set_phase(::TouchPoint_TouchPhase value);
  public:

  // float pressure = 5;
  void clear_pressure();
  float pressure() const;
  void set_pressure(float value);
  private:
  float _internal_pressure() const;
  void _internal_set_pressure(float value);
  public:

  // float size = 6;
  void clear_size();
  float size() const;
  void set_size(float value);
  private:
  float _internal_size() const;
  void _internal_set_size(float value);
  public:

  // @@protoc_insertion_point(class_scope:TouchPoint)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t id_;
    int32_t x_;
    int32_t y_;
    int phase_;
    float pressure_;
    float size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rendezvous_2eproto;
};
// -------------------------------------------------------------------

class TouchEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TouchEvent) */ {
 public:
  inline TouchEvent() : TouchEvent(nullptr) {}
  ~TouchEvent() override;
  explicit PROTOBUF_CONSTEXPR TouchEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TouchEvent(const TouchEvent& from);
  TouchEvent(TouchEvent&& from) noexcept
    : TouchEvent() {
    *this = ::std::move(from);
  }

  inline TouchEvent& operator=(const TouchEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline TouchEvent& operator=(TouchEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TouchEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const TouchEvent* internal_default_instance() {
    return reinterpret_cast<const TouchEvent*>(
               &_TouchEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(TouchEvent& a, TouchEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(TouchEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TouchEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TouchEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TouchEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TouchEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TouchEvent& from) {
    TouchEvent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TouchEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TouchEvent";
  }
  protected:
  explicit TouchEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPointsFieldNumber = 2,
    kTimestampFieldNumber = 1,
  };
  // repeated .TouchPoint points = 2;
  int points_size() const;
  private:
  int _internal_points_size() const;
  public:
  void clear_points();
  ::TouchPoint* mutable_points(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TouchPoint >*
      mutable_points();
  private:
  const ::TouchPoint& _internal_points(int index) const;
  ::TouchPoint* _internal_add_points();
  public:
  const ::TouchPoint& points(int index) const;
  ::TouchPoint* add_points();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TouchPoint >&
      points() const;

  // uint64 timestamp = 1;
  void clear_timestamp();
  uint64_t timestamp() const;
  void set_timestamp(uint64_t value);
  private:
  uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:TouchEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TouchPoint > points_;
    uint64_t timestamp_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rendezvous_2eproto;
};
// -------------------------------------------------------------------

class RendezvousMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RendezvousMessage) */ {
 public:
  inline RendezvousMessage() : RendezvousMessage(nullptr) {}
  ~RendezvousMessage() override;
  explicit PROTOBUF_CONSTEXPR RendezvousMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RendezvousMessage(const RendezvousMessage& from);
  RendezvousMessage(RendezvousMessage&& from) noexcept
    : RendezvousMessage() {
    *this = ::std::move(from);
  }

  inline RendezvousMessage& operator=(const RendezvousMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline RendezvousMessage& operator=(RendezvousMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RendezvousMessage& default_instance() {
    return *internal_default_instance();
  }
  enum UnionCase {
    kRequestRelay = 1,
    kRegisterPeer = 2,
    kRegisterPeerResponse = 3,
    kPunchHoleRequest = 4,
    kPunchHoleResponse = 5,
    kHeartbeat = 6,
    kPunchHole = 7,
    kPunchHoleSent = 8,
    kInpuVideoFrame = 9,
    kInputControlEvent = 10,
    kClipboardEvent = 11,
    UNION_NOT_SET = 0,
  };

  static inline const RendezvousMessage* internal_default_instance() {
    return reinterpret_cast<const RendezvousMessage*>(
               &_RendezvousMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(RendezvousMessage& a, RendezvousMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(RendezvousMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RendezvousMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RendezvousMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RendezvousMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RendezvousMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RendezvousMessage& from) {
    RendezvousMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RendezvousMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RendezvousMessage";
  }
  protected:
  explicit RendezvousMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestRelayFieldNumber = 1,
    kRegisterPeerFieldNumber = 2,
    kRegisterPeerResponseFieldNumber = 3,
    kPunchHoleRequestFieldNumber = 4,
    kPunchHoleResponseFieldNumber = 5,
    kHeartbeatFieldNumber = 6,
    kPunchHoleFieldNumber = 7,
    kPunchHoleSentFieldNumber = 8,
    kInpuVideoFrameFieldNumber = 9,
    kInputControlEventFieldNumber = 10,
    kClipboardEventFieldNumber = 11,
  };
  // .RequestRelay request_relay = 1;
  bool has_request_relay() const;
  private:
  bool _internal_has_request_relay() const;
  public:
  void clear_request_relay();
  const ::RequestRelay& request_relay() const;
  PROTOBUF_NODISCARD ::RequestRelay* release_request_relay();
  ::RequestRelay* mutable_request_relay();
  void set_allocated_request_relay(::RequestRelay* request_relay);
  private:
  const ::RequestRelay& _internal_request_relay() const;
  ::RequestRelay* _internal_mutable_request_relay();
  public:
  void unsafe_arena_set_allocated_request_relay(
      ::RequestRelay* request_relay);
  ::RequestRelay* unsafe_arena_release_request_relay();

  // .RegisterPeer register_peer = 2;
  bool has_register_peer() const;
  private:
  bool _internal_has_register_peer() const;
  public:
  void clear_register_peer();
  const ::RegisterPeer& register_peer() const;
  PROTOBUF_NODISCARD ::RegisterPeer* release_register_peer();
  ::RegisterPeer* mutable_register_peer();
  void set_allocated_register_peer(::RegisterPeer* register_peer);
  private:
  const ::RegisterPeer& _internal_register_peer() const;
  ::RegisterPeer* _internal_mutable_register_peer();
  public:
  void unsafe_arena_set_allocated_register_peer(
      ::RegisterPeer* register_peer);
  ::RegisterPeer* unsafe_arena_release_register_peer();

  // .RegisterPeerResponse register_peer_response = 3;
  bool has_register_peer_response() const;
  private:
  bool _internal_has_register_peer_response() const;
  public:
  void clear_register_peer_response();
  const ::RegisterPeerResponse& register_peer_response() const;
  PROTOBUF_NODISCARD ::RegisterPeerResponse* release_register_peer_response();
  ::RegisterPeerResponse* mutable_register_peer_response();
  void set_allocated_register_peer_response(::RegisterPeerResponse* register_peer_response);
  private:
  const ::RegisterPeerResponse& _internal_register_peer_response() const;
  ::RegisterPeerResponse* _internal_mutable_register_peer_response();
  public:
  void unsafe_arena_set_allocated_register_peer_response(
      ::RegisterPeerResponse* register_peer_response);
  ::RegisterPeerResponse* unsafe_arena_release_register_peer_response();

  // .PunchHoleRequest punch_hole_request = 4;
  bool has_punch_hole_request() const;
  private:
  bool _internal_has_punch_hole_request() const;
  public:
  void clear_punch_hole_request();
  const ::PunchHoleRequest& punch_hole_request() const;
  PROTOBUF_NODISCARD ::PunchHoleRequest* release_punch_hole_request();
  ::PunchHoleRequest* mutable_punch_hole_request();
  void set_allocated_punch_hole_request(::PunchHoleRequest* punch_hole_request);
  private:
  const ::PunchHoleRequest& _internal_punch_hole_request() const;
  ::PunchHoleRequest* _internal_mutable_punch_hole_request();
  public:
  void unsafe_arena_set_allocated_punch_hole_request(
      ::PunchHoleRequest* punch_hole_request);
  ::PunchHoleRequest* unsafe_arena_release_punch_hole_request();

  // .PunchHoleResponse punch_hole_response = 5;
  bool has_punch_hole_response() const;
  private:
  bool _internal_has_punch_hole_response() const;
  public:
  void clear_punch_hole_response();
  const ::PunchHoleResponse& punch_hole_response() const;
  PROTOBUF_NODISCARD ::PunchHoleResponse* release_punch_hole_response();
  ::PunchHoleResponse* mutable_punch_hole_response();
  void set_allocated_punch_hole_response(::PunchHoleResponse* punch_hole_response);
  private:
  const ::PunchHoleResponse& _internal_punch_hole_response() const;
  ::PunchHoleResponse* _internal_mutable_punch_hole_response();
  public:
  void unsafe_arena_set_allocated_punch_hole_response(
      ::PunchHoleResponse* punch_hole_response);
  ::PunchHoleResponse* unsafe_arena_release_punch_hole_response();

  // .Heartbeat heartbeat = 6;
  bool has_heartbeat() const;
  private:
  bool _internal_has_heartbeat() const;
  public:
  void clear_heartbeat();
  const ::Heartbeat& heartbeat() const;
  PROTOBUF_NODISCARD ::Heartbeat* release_heartbeat();
  ::Heartbeat* mutable_heartbeat();
  void set_allocated_heartbeat(::Heartbeat* heartbeat);
  private:
  const ::Heartbeat& _internal_heartbeat() const;
  ::Heartbeat* _internal_mutable_heartbeat();
  public:
  void unsafe_arena_set_allocated_heartbeat(
      ::Heartbeat* heartbeat);
  ::Heartbeat* unsafe_arena_release_heartbeat();

  // .PunchHole punch_hole = 7;
  bool has_punch_hole() const;
  private:
  bool _internal_has_punch_hole() const;
  public:
  void clear_punch_hole();
  const ::PunchHole& punch_hole() const;
  PROTOBUF_NODISCARD ::PunchHole* release_punch_hole();
  ::PunchHole* mutable_punch_hole();
  void set_allocated_punch_hole(::PunchHole* punch_hole);
  private:
  const ::PunchHole& _internal_punch_hole() const;
  ::PunchHole* _internal_mutable_punch_hole();
  public:
  void unsafe_arena_set_allocated_punch_hole(
      ::PunchHole* punch_hole);
  ::PunchHole* unsafe_arena_release_punch_hole();

  // .PunchHoleSent punch_hole_sent = 8;
  bool has_punch_hole_sent() const;
  private:
  bool _internal_has_punch_hole_sent() const;
  public:
  void clear_punch_hole_sent();
  const ::PunchHoleSent& punch_hole_sent() const;
  PROTOBUF_NODISCARD ::PunchHoleSent* release_punch_hole_sent();
  ::PunchHoleSent* mutable_punch_hole_sent();
  void set_allocated_punch_hole_sent(::PunchHoleSent* punch_hole_sent);
  private:
  const ::PunchHoleSent& _internal_punch_hole_sent() const;
  ::PunchHoleSent* _internal_mutable_punch_hole_sent();
  public:
  void unsafe_arena_set_allocated_punch_hole_sent(
      ::PunchHoleSent* punch_hole_sent);
  ::PunchHoleSent* unsafe_arena_release_punch_hole_sent();

  // .InpuVideoFrame inpuVideoFrame = 9;
  bool has_inpuvideoframe() const;
  private:
  bool _internal_has_inpuvideoframe() const;
  public:
  void clear_inpuvideoframe();
  const ::InpuVideoFrame& inpuvideoframe() const;
  PROTOBUF_NODISCARD ::InpuVideoFrame* release_inpuvideoframe();
  ::InpuVideoFrame* mutable_inpuvideoframe();
  void set_allocated_inpuvideoframe(::InpuVideoFrame* inpuvideoframe);
  private:
  const ::InpuVideoFrame& _internal_inpuvideoframe() const;
  ::InpuVideoFrame* _internal_mutable_inpuvideoframe();
  public:
  void unsafe_arena_set_allocated_inpuvideoframe(
      ::InpuVideoFrame* inpuvideoframe);
  ::InpuVideoFrame* unsafe_arena_release_inpuvideoframe();

  // .InputControlEvent inputControlEvent = 10;
  bool has_inputcontrolevent() const;
  private:
  bool _internal_has_inputcontrolevent() const;
  public:
  void clear_inputcontrolevent();
  const ::InputControlEvent& inputcontrolevent() const;
  PROTOBUF_NODISCARD ::InputControlEvent* release_inputcontrolevent();
  ::InputControlEvent* mutable_inputcontrolevent();
  void set_allocated_inputcontrolevent(::InputControlEvent* inputcontrolevent);
  private:
  const ::InputControlEvent& _internal_inputcontrolevent() const;
  ::InputControlEvent* _internal_mutable_inputcontrolevent();
  public:
  void unsafe_arena_set_allocated_inputcontrolevent(
      ::InputControlEvent* inputcontrolevent);
  ::InputControlEvent* unsafe_arena_release_inputcontrolevent();

  // .ClipboardEvent clipboardEvent = 11;
  bool has_clipboardevent() const;
  private:
  bool _internal_has_clipboardevent() const;
  public:
  void clear_clipboardevent();
  const ::ClipboardEvent& clipboardevent() const;
  PROTOBUF_NODISCARD ::ClipboardEvent* release_clipboardevent();
  ::ClipboardEvent* mutable_clipboardevent();
  void set_allocated_clipboardevent(::ClipboardEvent* clipboardevent);
  private:
  const ::ClipboardEvent& _internal_clipboardevent() const;
  ::ClipboardEvent* _internal_mutable_clipboardevent();
  public:
  void unsafe_arena_set_allocated_clipboardevent(
      ::ClipboardEvent* clipboardevent);
  ::ClipboardEvent* unsafe_arena_release_clipboardevent();

  void clear_union();
  UnionCase union_case() const;
  // @@protoc_insertion_point(class_scope:RendezvousMessage)
 private:
  class _Internal;
  void set_has_request_relay();
  void set_has_register_peer();
  void set_has_register_peer_response();
  void set_has_punch_hole_request();
  void set_has_punch_hole_response();
  void set_has_heartbeat();
  void set_has_punch_hole();
  void set_has_punch_hole_sent();
  void set_has_inpuvideoframe();
  void set_has_inputcontrolevent();
  void set_has_clipboardevent();

  inline bool has_union() const;
  inline void clear_has_union();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union UnionUnion {
      constexpr UnionUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::RequestRelay* request_relay_;
      ::RegisterPeer* register_peer_;
      ::RegisterPeerResponse* register_peer_response_;
      ::PunchHoleRequest* punch_hole_request_;
      ::PunchHoleResponse* punch_hole_response_;
      ::Heartbeat* heartbeat_;
      ::PunchHole* punch_hole_;
      ::PunchHoleSent* punch_hole_sent_;
      ::InpuVideoFrame* inpuvideoframe_;
      ::InputControlEvent* inputcontrolevent_;
      ::ClipboardEvent* clipboardevent_;
    } union_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_rendezvous_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// RequestRelay

// string uuid = 1;
inline void RequestRelay::clear_uuid() {
  _impl_.uuid_.ClearToEmpty();
}
inline const std::string& RequestRelay::uuid() const {
  // @@protoc_insertion_point(field_get:RequestRelay.uuid)
  return _internal_uuid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RequestRelay::set_uuid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.uuid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:RequestRelay.uuid)
}
inline std::string* RequestRelay::mutable_uuid() {
  std::string* _s = _internal_mutable_uuid();
  // @@protoc_insertion_point(field_mutable:RequestRelay.uuid)
  return _s;
}
inline const std::string& RequestRelay::_internal_uuid() const {
  return _impl_.uuid_.Get();
}
inline void RequestRelay::_internal_set_uuid(const std::string& value) {
  
  _impl_.uuid_.Set(value, GetArenaForAllocation());
}
inline std::string* RequestRelay::_internal_mutable_uuid() {
  
  return _impl_.uuid_.Mutable(GetArenaForAllocation());
}
inline std::string* RequestRelay::release_uuid() {
  // @@protoc_insertion_point(field_release:RequestRelay.uuid)
  return _impl_.uuid_.Release();
}
inline void RequestRelay::set_allocated_uuid(std::string* uuid) {
  if (uuid != nullptr) {
    
  } else {
    
  }
  _impl_.uuid_.SetAllocated(uuid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.uuid_.IsDefault()) {
    _impl_.uuid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:RequestRelay.uuid)
}

// .RequestRelay.DeskRole role = 2;
inline void RequestRelay::clear_role() {
  _impl_.role_ = 0;
}
inline ::RequestRelay_DeskRole RequestRelay::_internal_role() const {
  return static_cast< ::RequestRelay_DeskRole >(_impl_.role_);
}
inline ::RequestRelay_DeskRole RequestRelay::role() const {
  // @@protoc_insertion_point(field_get:RequestRelay.role)
  return _internal_role();
}
inline void RequestRelay::_internal_set_role(::RequestRelay_DeskRole value) {
  
  _impl_.role_ = value;
}
inline void RequestRelay::set_role(::RequestRelay_DeskRole value) {
  _internal_set_role(value);
  // @@protoc_insertion_point(field_set:RequestRelay.role)
}

// -------------------------------------------------------------------

// RegisterPeer

// bytes uuid = 1;
inline void RegisterPeer::clear_uuid() {
  _impl_.uuid_.ClearToEmpty();
}
inline const std::string& RegisterPeer::uuid() const {
  // @@protoc_insertion_point(field_get:RegisterPeer.uuid)
  return _internal_uuid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegisterPeer::set_uuid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.uuid_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:RegisterPeer.uuid)
}
inline std::string* RegisterPeer::mutable_uuid() {
  std::string* _s = _internal_mutable_uuid();
  // @@protoc_insertion_point(field_mutable:RegisterPeer.uuid)
  return _s;
}
inline const std::string& RegisterPeer::_internal_uuid() const {
  return _impl_.uuid_.Get();
}
inline void RegisterPeer::_internal_set_uuid(const std::string& value) {
  
  _impl_.uuid_.Set(value, GetArenaForAllocation());
}
inline std::string* RegisterPeer::_internal_mutable_uuid() {
  
  return _impl_.uuid_.Mutable(GetArenaForAllocation());
}
inline std::string* RegisterPeer::release_uuid() {
  // @@protoc_insertion_point(field_release:RegisterPeer.uuid)
  return _impl_.uuid_.Release();
}
inline void RegisterPeer::set_allocated_uuid(std::string* uuid) {
  if (uuid != nullptr) {
    
  } else {
    
  }
  _impl_.uuid_.SetAllocated(uuid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.uuid_.IsDefault()) {
    _impl_.uuid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:RegisterPeer.uuid)
}

// -------------------------------------------------------------------

// RegisterPeerResponse

// .Result result = 1;
inline void RegisterPeerResponse::clear_result() {
  _impl_.result_ = 0;
}
inline ::Result RegisterPeerResponse::_internal_result() const {
  return static_cast< ::Result >(_impl_.result_);
}
inline ::Result RegisterPeerResponse::result() const {
  // @@protoc_insertion_point(field_get:RegisterPeerResponse.result)
  return _internal_result();
}
inline void RegisterPeerResponse::_internal_set_result(::Result value) {
  
  _impl_.result_ = value;
}
inline void RegisterPeerResponse::set_result(::Result value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:RegisterPeerResponse.result)
}

// -------------------------------------------------------------------

// PunchHoleRequest

// bytes uuid = 1;
inline void PunchHoleRequest::clear_uuid() {
  _impl_.uuid_.ClearToEmpty();
}
inline const std::string& PunchHoleRequest::uuid() const {
  // @@protoc_insertion_point(field_get:PunchHoleRequest.uuid)
  return _internal_uuid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PunchHoleRequest::set_uuid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.uuid_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PunchHoleRequest.uuid)
}
inline std::string* PunchHoleRequest::mutable_uuid() {
  std::string* _s = _internal_mutable_uuid();
  // @@protoc_insertion_point(field_mutable:PunchHoleRequest.uuid)
  return _s;
}
inline const std::string& PunchHoleRequest::_internal_uuid() const {
  return _impl_.uuid_.Get();
}
inline void PunchHoleRequest::_internal_set_uuid(const std::string& value) {
  
  _impl_.uuid_.Set(value, GetArenaForAllocation());
}
inline std::string* PunchHoleRequest::_internal_mutable_uuid() {
  
  return _impl_.uuid_.Mutable(GetArenaForAllocation());
}
inline std::string* PunchHoleRequest::release_uuid() {
  // @@protoc_insertion_point(field_release:PunchHoleRequest.uuid)
  return _impl_.uuid_.Release();
}
inline void PunchHoleRequest::set_allocated_uuid(std::string* uuid) {
  if (uuid != nullptr) {
    
  } else {
    
  }
  _impl_.uuid_.SetAllocated(uuid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.uuid_.IsDefault()) {
    _impl_.uuid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PunchHoleRequest.uuid)
}

// bytes id = 2;
inline void PunchHoleRequest::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& PunchHoleRequest::id() const {
  // @@protoc_insertion_point(field_get:PunchHoleRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PunchHoleRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PunchHoleRequest.id)
}
inline std::string* PunchHoleRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:PunchHoleRequest.id)
  return _s;
}
inline const std::string& PunchHoleRequest::_internal_id() const {
  return _impl_.id_.Get();
}
inline void PunchHoleRequest::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* PunchHoleRequest::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* PunchHoleRequest::release_id() {
  // @@protoc_insertion_point(field_release:PunchHoleRequest.id)
  return _impl_.id_.Release();
}
inline void PunchHoleRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PunchHoleRequest.id)
}

// -------------------------------------------------------------------

// PunchHoleResponse

// string relay_server = 1;
inline void PunchHoleResponse::clear_relay_server() {
  _impl_.relay_server_.ClearToEmpty();
}
inline const std::string& PunchHoleResponse::relay_server() const {
  // @@protoc_insertion_point(field_get:PunchHoleResponse.relay_server)
  return _internal_relay_server();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PunchHoleResponse::set_relay_server(ArgT0&& arg0, ArgT... args) {
 
 _impl_.relay_server_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PunchHoleResponse.relay_server)
}
inline std::string* PunchHoleResponse::mutable_relay_server() {
  std::string* _s = _internal_mutable_relay_server();
  // @@protoc_insertion_point(field_mutable:PunchHoleResponse.relay_server)
  return _s;
}
inline const std::string& PunchHoleResponse::_internal_relay_server() const {
  return _impl_.relay_server_.Get();
}
inline void PunchHoleResponse::_internal_set_relay_server(const std::string& value) {
  
  _impl_.relay_server_.Set(value, GetArenaForAllocation());
}
inline std::string* PunchHoleResponse::_internal_mutable_relay_server() {
  
  return _impl_.relay_server_.Mutable(GetArenaForAllocation());
}
inline std::string* PunchHoleResponse::release_relay_server() {
  // @@protoc_insertion_point(field_release:PunchHoleResponse.relay_server)
  return _impl_.relay_server_.Release();
}
inline void PunchHoleResponse::set_allocated_relay_server(std::string* relay_server) {
  if (relay_server != nullptr) {
    
  } else {
    
  }
  _impl_.relay_server_.SetAllocated(relay_server, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.relay_server_.IsDefault()) {
    _impl_.relay_server_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PunchHoleResponse.relay_server)
}

// int32 relay_port = 2;
inline void PunchHoleResponse::clear_relay_port() {
  _impl_.relay_port_ = 0;
}
inline int32_t PunchHoleResponse::_internal_relay_port() const {
  return _impl_.relay_port_;
}
inline int32_t PunchHoleResponse::relay_port() const {
  // @@protoc_insertion_point(field_get:PunchHoleResponse.relay_port)
  return _internal_relay_port();
}
inline void PunchHoleResponse::_internal_set_relay_port(int32_t value) {
  
  _impl_.relay_port_ = value;
}
inline void PunchHoleResponse::set_relay_port(int32_t value) {
  _internal_set_relay_port(value);
  // @@protoc_insertion_point(field_set:PunchHoleResponse.relay_port)
}

// .Result result = 3;
inline void PunchHoleResponse::clear_result() {
  _impl_.result_ = 0;
}
inline ::Result PunchHoleResponse::_internal_result() const {
  return static_cast< ::Result >(_impl_.result_);
}
inline ::Result PunchHoleResponse::result() const {
  // @@protoc_insertion_point(field_get:PunchHoleResponse.result)
  return _internal_result();
}
inline void PunchHoleResponse::_internal_set_result(::Result value) {
  
  _impl_.result_ = value;
}
inline void PunchHoleResponse::set_result(::Result value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:PunchHoleResponse.result)
}

// -------------------------------------------------------------------

// Heartbeat

// -------------------------------------------------------------------

// PunchHole

// bytes id = 1;
inline void PunchHole::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& PunchHole::id() const {
  // @@protoc_insertion_point(field_get:PunchHole.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PunchHole::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PunchHole.id)
}
inline std::string* PunchHole::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:PunchHole.id)
  return _s;
}
inline const std::string& PunchHole::_internal_id() const {
  return _impl_.id_.Get();
}
inline void PunchHole::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* PunchHole::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* PunchHole::release_id() {
  // @@protoc_insertion_point(field_release:PunchHole.id)
  return _impl_.id_.Release();
}
inline void PunchHole::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PunchHole.id)
}

// -------------------------------------------------------------------

// PunchHoleSent

// string relay_server = 1;
inline void PunchHoleSent::clear_relay_server() {
  _impl_.relay_server_.ClearToEmpty();
}
inline const std::string& PunchHoleSent::relay_server() const {
  // @@protoc_insertion_point(field_get:PunchHoleSent.relay_server)
  return _internal_relay_server();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PunchHoleSent::set_relay_server(ArgT0&& arg0, ArgT... args) {
 
 _impl_.relay_server_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PunchHoleSent.relay_server)
}
inline std::string* PunchHoleSent::mutable_relay_server() {
  std::string* _s = _internal_mutable_relay_server();
  // @@protoc_insertion_point(field_mutable:PunchHoleSent.relay_server)
  return _s;
}
inline const std::string& PunchHoleSent::_internal_relay_server() const {
  return _impl_.relay_server_.Get();
}
inline void PunchHoleSent::_internal_set_relay_server(const std::string& value) {
  
  _impl_.relay_server_.Set(value, GetArenaForAllocation());
}
inline std::string* PunchHoleSent::_internal_mutable_relay_server() {
  
  return _impl_.relay_server_.Mutable(GetArenaForAllocation());
}
inline std::string* PunchHoleSent::release_relay_server() {
  // @@protoc_insertion_point(field_release:PunchHoleSent.relay_server)
  return _impl_.relay_server_.Release();
}
inline void PunchHoleSent::set_allocated_relay_server(std::string* relay_server) {
  if (relay_server != nullptr) {
    
  } else {
    
  }
  _impl_.relay_server_.SetAllocated(relay_server, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.relay_server_.IsDefault()) {
    _impl_.relay_server_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PunchHoleSent.relay_server)
}

// int32 relay_port = 2;
inline void PunchHoleSent::clear_relay_port() {
  _impl_.relay_port_ = 0;
}
inline int32_t PunchHoleSent::_internal_relay_port() const {
  return _impl_.relay_port_;
}
inline int32_t PunchHoleSent::relay_port() const {
  // @@protoc_insertion_point(field_get:PunchHoleSent.relay_port)
  return _internal_relay_port();
}
inline void PunchHoleSent::_internal_set_relay_port(int32_t value) {
  
  _impl_.relay_port_ = value;
}
inline void PunchHoleSent::set_relay_port(int32_t value) {
  _internal_set_relay_port(value);
  // @@protoc_insertion_point(field_set:PunchHoleSent.relay_port)
}

// .Result result = 3;
inline void PunchHoleSent::clear_result() {
  _impl_.result_ = 0;
}
inline ::Result PunchHoleSent::_internal_result() const {
  return static_cast< ::Result >(_impl_.result_);
}
inline ::Result PunchHoleSent::result() const {
  // @@protoc_insertion_point(field_get:PunchHoleSent.result)
  return _internal_result();
}
inline void PunchHoleSent::_internal_set_result(::Result value) {
  
  _impl_.result_ = value;
}
inline void PunchHoleSent::set_result(::Result value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:PunchHoleSent.result)
}

// bytes id = 4;
inline void PunchHoleSent::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& PunchHoleSent::id() const {
  // @@protoc_insertion_point(field_get:PunchHoleSent.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PunchHoleSent::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:PunchHoleSent.id)
}
inline std::string* PunchHoleSent::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:PunchHoleSent.id)
  return _s;
}
inline const std::string& PunchHoleSent::_internal_id() const {
  return _impl_.id_.Get();
}
inline void PunchHoleSent::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* PunchHoleSent::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* PunchHoleSent::release_id() {
  // @@protoc_insertion_point(field_release:PunchHoleSent.id)
  return _impl_.id_.Release();
}
inline void PunchHoleSent::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:PunchHoleSent.id)
}

// -------------------------------------------------------------------

// InputControlEvent

// .MouseEvent mouse_event = 1;
inline bool InputControlEvent::_internal_has_mouse_event() const {
  return event_case() == kMouseEvent;
}
inline bool InputControlEvent::has_mouse_event() const {
  return _internal_has_mouse_event();
}
inline void InputControlEvent::set_has_mouse_event() {
  _impl_._oneof_case_[0] = kMouseEvent;
}
inline void InputControlEvent::clear_mouse_event() {
  if (_internal_has_mouse_event()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.event_.mouse_event_;
    }
    clear_has_event();
  }
}
inline ::MouseEvent* InputControlEvent::release_mouse_event() {
  // @@protoc_insertion_point(field_release:InputControlEvent.mouse_event)
  if (_internal_has_mouse_event()) {
    clear_has_event();
    ::MouseEvent* temp = _impl_.event_.mouse_event_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_.mouse_event_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::MouseEvent& InputControlEvent::_internal_mouse_event() const {
  return _internal_has_mouse_event()
      ? *_impl_.event_.mouse_event_
      : reinterpret_cast< ::MouseEvent&>(::_MouseEvent_default_instance_);
}
inline const ::MouseEvent& InputControlEvent::mouse_event() const {
  // @@protoc_insertion_point(field_get:InputControlEvent.mouse_event)
  return _internal_mouse_event();
}
inline ::MouseEvent* InputControlEvent::unsafe_arena_release_mouse_event() {
  // @@protoc_insertion_point(field_unsafe_arena_release:InputControlEvent.mouse_event)
  if (_internal_has_mouse_event()) {
    clear_has_event();
    ::MouseEvent* temp = _impl_.event_.mouse_event_;
    _impl_.event_.mouse_event_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InputControlEvent::unsafe_arena_set_allocated_mouse_event(::MouseEvent* mouse_event) {
  clear_event();
  if (mouse_event) {
    set_has_mouse_event();
    _impl_.event_.mouse_event_ = mouse_event;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:InputControlEvent.mouse_event)
}
inline ::MouseEvent* InputControlEvent::_internal_mutable_mouse_event() {
  if (!_internal_has_mouse_event()) {
    clear_event();
    set_has_mouse_event();
    _impl_.event_.mouse_event_ = CreateMaybeMessage< ::MouseEvent >(GetArenaForAllocation());
  }
  return _impl_.event_.mouse_event_;
}
inline ::MouseEvent* InputControlEvent::mutable_mouse_event() {
  ::MouseEvent* _msg = _internal_mutable_mouse_event();
  // @@protoc_insertion_point(field_mutable:InputControlEvent.mouse_event)
  return _msg;
}

// .KeyboardEvent keyboard_event = 2;
inline bool InputControlEvent::_internal_has_keyboard_event() const {
  return event_case() == kKeyboardEvent;
}
inline bool InputControlEvent::has_keyboard_event() const {
  return _internal_has_keyboard_event();
}
inline void InputControlEvent::set_has_keyboard_event() {
  _impl_._oneof_case_[0] = kKeyboardEvent;
}
inline void InputControlEvent::clear_keyboard_event() {
  if (_internal_has_keyboard_event()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.event_.keyboard_event_;
    }
    clear_has_event();
  }
}
inline ::KeyboardEvent* InputControlEvent::release_keyboard_event() {
  // @@protoc_insertion_point(field_release:InputControlEvent.keyboard_event)
  if (_internal_has_keyboard_event()) {
    clear_has_event();
    ::KeyboardEvent* temp = _impl_.event_.keyboard_event_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_.keyboard_event_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::KeyboardEvent& InputControlEvent::_internal_keyboard_event() const {
  return _internal_has_keyboard_event()
      ? *_impl_.event_.keyboard_event_
      : reinterpret_cast< ::KeyboardEvent&>(::_KeyboardEvent_default_instance_);
}
inline const ::KeyboardEvent& InputControlEvent::keyboard_event() const {
  // @@protoc_insertion_point(field_get:InputControlEvent.keyboard_event)
  return _internal_keyboard_event();
}
inline ::KeyboardEvent* InputControlEvent::unsafe_arena_release_keyboard_event() {
  // @@protoc_insertion_point(field_unsafe_arena_release:InputControlEvent.keyboard_event)
  if (_internal_has_keyboard_event()) {
    clear_has_event();
    ::KeyboardEvent* temp = _impl_.event_.keyboard_event_;
    _impl_.event_.keyboard_event_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InputControlEvent::unsafe_arena_set_allocated_keyboard_event(::KeyboardEvent* keyboard_event) {
  clear_event();
  if (keyboard_event) {
    set_has_keyboard_event();
    _impl_.event_.keyboard_event_ = keyboard_event;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:InputControlEvent.keyboard_event)
}
inline ::KeyboardEvent* InputControlEvent::_internal_mutable_keyboard_event() {
  if (!_internal_has_keyboard_event()) {
    clear_event();
    set_has_keyboard_event();
    _impl_.event_.keyboard_event_ = CreateMaybeMessage< ::KeyboardEvent >(GetArenaForAllocation());
  }
  return _impl_.event_.keyboard_event_;
}
inline ::KeyboardEvent* InputControlEvent::mutable_keyboard_event() {
  ::KeyboardEvent* _msg = _internal_mutable_keyboard_event();
  // @@protoc_insertion_point(field_mutable:InputControlEvent.keyboard_event)
  return _msg;
}

// .TouchEvent touch_event = 3;
inline bool InputControlEvent::_internal_has_touch_event() const {
  return event_case() == kTouchEvent;
}
inline bool InputControlEvent::has_touch_event() const {
  return _internal_has_touch_event();
}
inline void InputControlEvent::set_has_touch_event() {
  _impl_._oneof_case_[0] = kTouchEvent;
}
inline void InputControlEvent::clear_touch_event() {
  if (_internal_has_touch_event()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.event_.touch_event_;
    }
    clear_has_event();
  }
}
inline ::TouchEvent* InputControlEvent::release_touch_event() {
  // @@protoc_insertion_point(field_release:InputControlEvent.touch_event)
  if (_internal_has_touch_event()) {
    clear_has_event();
    ::TouchEvent* temp = _impl_.event_.touch_event_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_.touch_event_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::TouchEvent& InputControlEvent::_internal_touch_event() const {
  return _internal_has_touch_event()
      ? *_impl_.event_.touch_event_
      : reinterpret_cast< ::TouchEvent&>(::_TouchEvent_default_instance_);
}
inline const ::TouchEvent& InputControlEvent::touch_event() const {
  // @@protoc_insertion_point(field_get:InputControlEvent.touch_event)
  return _internal_touch_event();
}
inline ::TouchEvent* InputControlEvent::unsafe_arena_release_touch_event() {
  // @@protoc_insertion_point(field_unsafe_arena_release:InputControlEvent.touch_event)
  if (_internal_has_touch_event()) {
    clear_has_event();
    ::TouchEvent* temp = _impl_.event_.touch_event_;
    _impl_.event_.touch_event_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void InputControlEvent::unsafe_arena_set_allocated_touch_event(::TouchEvent* touch_event) {
  clear_event();
  if (touch_event) {
    set_has_touch_event();
    _impl_.event_.touch_event_ = touch_event;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:InputControlEvent.touch_event)
}
inline ::TouchEvent* InputControlEvent::_internal_mutable_touch_event() {
  if (!_internal_has_touch_event()) {
    clear_event();
    set_has_touch_event();
    _impl_.event_.touch_event_ = CreateMaybeMessage< ::TouchEvent >(GetArenaForAllocation());
  }
  return _impl_.event_.touch_event_;
}
inline ::TouchEvent* InputControlEvent::mutable_touch_event() {
  ::TouchEvent* _msg = _internal_mutable_touch_event();
  // @@protoc_insertion_point(field_mutable:InputControlEvent.touch_event)
  return _msg;
}

inline bool InputControlEvent::has_event() const {
  return event_case() != EVENT_NOT_SET;
}
inline void InputControlEvent::clear_has_event() {
  _impl_._oneof_case_[0] = EVENT_NOT_SET;
}
inline InputControlEvent::EventCase InputControlEvent::event_case() const {
  return InputControlEvent::EventCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ClipboardEvent

// .TextContent text = 1;
inline bool ClipboardEvent::_internal_has_text() const {
  return event_case() == kText;
}
inline bool ClipboardEvent::has_text() const {
  return _internal_has_text();
}
inline void ClipboardEvent::set_has_text() {
  _impl_._oneof_case_[0] = kText;
}
inline void ClipboardEvent::clear_text() {
  if (_internal_has_text()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.event_.text_;
    }
    clear_has_event();
  }
}
inline ::TextContent* ClipboardEvent::release_text() {
  // @@protoc_insertion_point(field_release:ClipboardEvent.text)
  if (_internal_has_text()) {
    clear_has_event();
    ::TextContent* temp = _impl_.event_.text_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_.text_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::TextContent& ClipboardEvent::_internal_text() const {
  return _internal_has_text()
      ? *_impl_.event_.text_
      : reinterpret_cast< ::TextContent&>(::_TextContent_default_instance_);
}
inline const ::TextContent& ClipboardEvent::text() const {
  // @@protoc_insertion_point(field_get:ClipboardEvent.text)
  return _internal_text();
}
inline ::TextContent* ClipboardEvent::unsafe_arena_release_text() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ClipboardEvent.text)
  if (_internal_has_text()) {
    clear_has_event();
    ::TextContent* temp = _impl_.event_.text_;
    _impl_.event_.text_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ClipboardEvent::unsafe_arena_set_allocated_text(::TextContent* text) {
  clear_event();
  if (text) {
    set_has_text();
    _impl_.event_.text_ = text;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ClipboardEvent.text)
}
inline ::TextContent* ClipboardEvent::_internal_mutable_text() {
  if (!_internal_has_text()) {
    clear_event();
    set_has_text();
    _impl_.event_.text_ = CreateMaybeMessage< ::TextContent >(GetArenaForAllocation());
  }
  return _impl_.event_.text_;
}
inline ::TextContent* ClipboardEvent::mutable_text() {
  ::TextContent* _msg = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:ClipboardEvent.text)
  return _msg;
}

// .FileContent file = 2;
inline bool ClipboardEvent::_internal_has_file() const {
  return event_case() == kFile;
}
inline bool ClipboardEvent::has_file() const {
  return _internal_has_file();
}
inline void ClipboardEvent::set_has_file() {
  _impl_._oneof_case_[0] = kFile;
}
inline void ClipboardEvent::clear_file() {
  if (_internal_has_file()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.event_.file_;
    }
    clear_has_event();
  }
}
inline ::FileContent* ClipboardEvent::release_file() {
  // @@protoc_insertion_point(field_release:ClipboardEvent.file)
  if (_internal_has_file()) {
    clear_has_event();
    ::FileContent* temp = _impl_.event_.file_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.event_.file_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::FileContent& ClipboardEvent::_internal_file() const {
  return _internal_has_file()
      ? *_impl_.event_.file_
      : reinterpret_cast< ::FileContent&>(::_FileContent_default_instance_);
}
inline const ::FileContent& ClipboardEvent::file() const {
  // @@protoc_insertion_point(field_get:ClipboardEvent.file)
  return _internal_file();
}
inline ::FileContent* ClipboardEvent::unsafe_arena_release_file() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ClipboardEvent.file)
  if (_internal_has_file()) {
    clear_has_event();
    ::FileContent* temp = _impl_.event_.file_;
    _impl_.event_.file_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ClipboardEvent::unsafe_arena_set_allocated_file(::FileContent* file) {
  clear_event();
  if (file) {
    set_has_file();
    _impl_.event_.file_ = file;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ClipboardEvent.file)
}
inline ::FileContent* ClipboardEvent::_internal_mutable_file() {
  if (!_internal_has_file()) {
    clear_event();
    set_has_file();
    _impl_.event_.file_ = CreateMaybeMessage< ::FileContent >(GetArenaForAllocation());
  }
  return _impl_.event_.file_;
}
inline ::FileContent* ClipboardEvent::mutable_file() {
  ::FileContent* _msg = _internal_mutable_file();
  // @@protoc_insertion_point(field_mutable:ClipboardEvent.file)
  return _msg;
}

inline bool ClipboardEvent::has_event() const {
  return event_case() != EVENT_NOT_SET;
}
inline void ClipboardEvent::clear_has_event() {
  _impl_._oneof_case_[0] = EVENT_NOT_SET;
}
inline ClipboardEvent::EventCase ClipboardEvent::event_case() const {
  return ClipboardEvent::EventCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// TextContent

// string text_data = 1;
inline void TextContent::clear_text_data() {
  _impl_.text_data_.ClearToEmpty();
}
inline const std::string& TextContent::text_data() const {
  // @@protoc_insertion_point(field_get:TextContent.text_data)
  return _internal_text_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TextContent::set_text_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.text_data_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TextContent.text_data)
}
inline std::string* TextContent::mutable_text_data() {
  std::string* _s = _internal_mutable_text_data();
  // @@protoc_insertion_point(field_mutable:TextContent.text_data)
  return _s;
}
inline const std::string& TextContent::_internal_text_data() const {
  return _impl_.text_data_.Get();
}
inline void TextContent::_internal_set_text_data(const std::string& value) {
  
  _impl_.text_data_.Set(value, GetArenaForAllocation());
}
inline std::string* TextContent::_internal_mutable_text_data() {
  
  return _impl_.text_data_.Mutable(GetArenaForAllocation());
}
inline std::string* TextContent::release_text_data() {
  // @@protoc_insertion_point(field_release:TextContent.text_data)
  return _impl_.text_data_.Release();
}
inline void TextContent::set_allocated_text_data(std::string* text_data) {
  if (text_data != nullptr) {
    
  } else {
    
  }
  _impl_.text_data_.SetAllocated(text_data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.text_data_.IsDefault()) {
    _impl_.text_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TextContent.text_data)
}

// -------------------------------------------------------------------

// FileContent

// bytes file_data = 1;
inline void FileContent::clear_file_data() {
  _impl_.file_data_.ClearToEmpty();
}
inline const std::string& FileContent::file_data() const {
  // @@protoc_insertion_point(field_get:FileContent.file_data)
  return _internal_file_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FileContent::set_file_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.file_data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:FileContent.file_data)
}
inline std::string* FileContent::mutable_file_data() {
  std::string* _s = _internal_mutable_file_data();
  // @@protoc_insertion_point(field_mutable:FileContent.file_data)
  return _s;
}
inline const std::string& FileContent::_internal_file_data() const {
  return _impl_.file_data_.Get();
}
inline void FileContent::_internal_set_file_data(const std::string& value) {
  
  _impl_.file_data_.Set(value, GetArenaForAllocation());
}
inline std::string* FileContent::_internal_mutable_file_data() {
  
  return _impl_.file_data_.Mutable(GetArenaForAllocation());
}
inline std::string* FileContent::release_file_data() {
  // @@protoc_insertion_point(field_release:FileContent.file_data)
  return _impl_.file_data_.Release();
}
inline void FileContent::set_allocated_file_data(std::string* file_data) {
  if (file_data != nullptr) {
    
  } else {
    
  }
  _impl_.file_data_.SetAllocated(file_data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.file_data_.IsDefault()) {
    _impl_.file_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:FileContent.file_data)
}

// string file_name = 2;
inline void FileContent::clear_file_name() {
  _impl_.file_name_.ClearToEmpty();
}
inline const std::string& FileContent::file_name() const {
  // @@protoc_insertion_point(field_get:FileContent.file_name)
  return _internal_file_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FileContent::set_file_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.file_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:FileContent.file_name)
}
inline std::string* FileContent::mutable_file_name() {
  std::string* _s = _internal_mutable_file_name();
  // @@protoc_insertion_point(field_mutable:FileContent.file_name)
  return _s;
}
inline const std::string& FileContent::_internal_file_name() const {
  return _impl_.file_name_.Get();
}
inline void FileContent::_internal_set_file_name(const std::string& value) {
  
  _impl_.file_name_.Set(value, GetArenaForAllocation());
}
inline std::string* FileContent::_internal_mutable_file_name() {
  
  return _impl_.file_name_.Mutable(GetArenaForAllocation());
}
inline std::string* FileContent::release_file_name() {
  // @@protoc_insertion_point(field_release:FileContent.file_name)
  return _impl_.file_name_.Release();
}
inline void FileContent::set_allocated_file_name(std::string* file_name) {
  if (file_name != nullptr) {
    
  } else {
    
  }
  _impl_.file_name_.SetAllocated(file_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.file_name_.IsDefault()) {
    _impl_.file_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:FileContent.file_name)
}

// -------------------------------------------------------------------

// InpuVideoFrame

// bytes data = 1;
inline void InpuVideoFrame::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& InpuVideoFrame::data() const {
  // @@protoc_insertion_point(field_get:InpuVideoFrame.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InpuVideoFrame::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:InpuVideoFrame.data)
}
inline std::string* InpuVideoFrame::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:InpuVideoFrame.data)
  return _s;
}
inline const std::string& InpuVideoFrame::_internal_data() const {
  return _impl_.data_.Get();
}
inline void InpuVideoFrame::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* InpuVideoFrame::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* InpuVideoFrame::release_data() {
  // @@protoc_insertion_point(field_release:InpuVideoFrame.data)
  return _impl_.data_.Release();
}
inline void InpuVideoFrame::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:InpuVideoFrame.data)
}

// -------------------------------------------------------------------

// MouseEvent

// int32 mask = 1;
inline void MouseEvent::clear_mask() {
  _impl_.mask_ = 0;
}
inline int32_t MouseEvent::_internal_mask() const {
  return _impl_.mask_;
}
inline int32_t MouseEvent::mask() const {
  // @@protoc_insertion_point(field_get:MouseEvent.mask)
  return _internal_mask();
}
inline void MouseEvent::_internal_set_mask(int32_t value) {
  
  _impl_.mask_ = value;
}
inline void MouseEvent::set_mask(int32_t value) {
  _internal_set_mask(value);
  // @@protoc_insertion_point(field_set:MouseEvent.mask)
}

// sint32 x = 2;
inline void MouseEvent::clear_x() {
  _impl_.x_ = 0;
}
inline int32_t MouseEvent::_internal_x() const {
  return _impl_.x_;
}
inline int32_t MouseEvent::x() const {
  // @@protoc_insertion_point(field_get:MouseEvent.x)
  return _internal_x();
}
inline void MouseEvent::_internal_set_x(int32_t value) {
  
  _impl_.x_ = value;
}
inline void MouseEvent::set_x(int32_t value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:MouseEvent.x)
}

// sint32 y = 3;
inline void MouseEvent::clear_y() {
  _impl_.y_ = 0;
}
inline int32_t MouseEvent::_internal_y() const {
  return _impl_.y_;
}
inline int32_t MouseEvent::y() const {
  // @@protoc_insertion_point(field_get:MouseEvent.y)
  return _internal_y();
}
inline void MouseEvent::_internal_set_y(int32_t value) {
  
  _impl_.y_ = value;
}
inline void MouseEvent::set_y(int32_t value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:MouseEvent.y)
}

// sint32 value = 4;
inline void MouseEvent::clear_value() {
  _impl_.value_ = 0;
}
inline int32_t MouseEvent::_internal_value() const {
  return _impl_.value_;
}
inline int32_t MouseEvent::value() const {
  // @@protoc_insertion_point(field_get:MouseEvent.value)
  return _internal_value();
}
inline void MouseEvent::_internal_set_value(int32_t value) {
  
  _impl_.value_ = value;
}
inline void MouseEvent::set_value(int32_t value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:MouseEvent.value)
}

// repeated int32 modifiers = 5;
inline int MouseEvent::_internal_modifiers_size() const {
  return _impl_.modifiers_.size();
}
inline int MouseEvent::modifiers_size() const {
  return _internal_modifiers_size();
}
inline void MouseEvent::clear_modifiers() {
  _impl_.modifiers_.Clear();
}
inline int32_t MouseEvent::_internal_modifiers(int index) const {
  return _impl_.modifiers_.Get(index);
}
inline int32_t MouseEvent::modifiers(int index) const {
  // @@protoc_insertion_point(field_get:MouseEvent.modifiers)
  return _internal_modifiers(index);
}
inline void MouseEvent::set_modifiers(int index, int32_t value) {
  _impl_.modifiers_.Set(index, value);
  // @@protoc_insertion_point(field_set:MouseEvent.modifiers)
}
inline void MouseEvent::_internal_add_modifiers(int32_t value) {
  _impl_.modifiers_.Add(value);
}
inline void MouseEvent::add_modifiers(int32_t value) {
  _internal_add_modifiers(value);
  // @@protoc_insertion_point(field_add:MouseEvent.modifiers)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
MouseEvent::_internal_modifiers() const {
  return _impl_.modifiers_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
MouseEvent::modifiers() const {
  // @@protoc_insertion_point(field_list:MouseEvent.modifiers)
  return _internal_modifiers();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
MouseEvent::_internal_mutable_modifiers() {
  return &_impl_.modifiers_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
MouseEvent::mutable_modifiers() {
  // @@protoc_insertion_point(field_mutable_list:MouseEvent.modifiers)
  return _internal_mutable_modifiers();
}

// -------------------------------------------------------------------

// KeyboardEvent

// int32 key = 2;
inline void KeyboardEvent::clear_key() {
  _impl_.key_ = 0;
}
inline int32_t KeyboardEvent::_internal_key() const {
  return _impl_.key_;
}
inline int32_t KeyboardEvent::key() const {
  // @@protoc_insertion_point(field_get:KeyboardEvent.key)
  return _internal_key();
}
inline void KeyboardEvent::_internal_set_key(int32_t value) {
  
  _impl_.key_ = value;
}
inline void KeyboardEvent::set_key(int32_t value) {
  _internal_set_key(value);
  // @@protoc_insertion_point(field_set:KeyboardEvent.key)
}

// bool pressed = 3;
inline void KeyboardEvent::clear_pressed() {
  _impl_.pressed_ = false;
}
inline bool KeyboardEvent::_internal_pressed() const {
  return _impl_.pressed_;
}
inline bool KeyboardEvent::pressed() const {
  // @@protoc_insertion_point(field_get:KeyboardEvent.pressed)
  return _internal_pressed();
}
inline void KeyboardEvent::_internal_set_pressed(bool value) {
  
  _impl_.pressed_ = value;
}
inline void KeyboardEvent::set_pressed(bool value) {
  _internal_set_pressed(value);
  // @@protoc_insertion_point(field_set:KeyboardEvent.pressed)
}

// -------------------------------------------------------------------

// TouchPoint

// int32 id = 1;
inline void TouchPoint::clear_id() {
  _impl_.id_ = 0;
}
inline int32_t TouchPoint::_internal_id() const {
  return _impl_.id_;
}
inline int32_t TouchPoint::id() const {
  // @@protoc_insertion_point(field_get:TouchPoint.id)
  return _internal_id();
}
inline void TouchPoint::_internal_set_id(int32_t value) {
  
  _impl_.id_ = value;
}
inline void TouchPoint::set_id(int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:TouchPoint.id)
}

// sint32 x = 2;
inline void TouchPoint::clear_x() {
  _impl_.x_ = 0;
}
inline int32_t TouchPoint::_internal_x() const {
  return _impl_.x_;
}
inline int32_t TouchPoint::x() const {
  // @@protoc_insertion_point(field_get:TouchPoint.x)
  return _internal_x();
}
inline void TouchPoint::_internal_set_x(int32_t value) {
  
  _impl_.x_ = value;
}
inline void TouchPoint::set_x(int32_t value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:TouchPoint.x)
}

// sint32 y = 3;
inline void TouchPoint::clear_y() {
  _impl_.y_ = 0;
}
inline int32_t TouchPoint::_internal_y() const {
  return _impl_.y_;
}
inline int32_t TouchPoint::y() const {
  // @@protoc_insertion_point(field_get:TouchPoint.y)
  return _internal_y();
}
inline void TouchPoint::_internal_set_y(int32_t value) {
  
  _impl_.y_ = value;
}
inline void TouchPoint::set_y(int32_t value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:TouchPoint.y)
}

// .TouchPoint.TouchPhase phase = 4;
inline void TouchPoint::clear_phase() {
  _impl_.phase_ = 0;
}
inline ::TouchPoint_TouchPhase TouchPoint::_internal_phase() const {
  return static_cast< ::TouchPoint_TouchPhase >(_impl_.phase_);
}
inline ::TouchPoint_TouchPhase TouchPoint::phase() const {
  // @@protoc_insertion_point(field_get:TouchPoint.phase)
  return _internal_phase();
}
inline void TouchPoint::_internal_set_phase(::TouchPoint_TouchPhase value) {
  
  _impl_.phase_ = value;
}
inline void TouchPoint::set_phase(::TouchPoint_TouchPhase value) {
  _internal_set_phase(value);
  // @@protoc_insertion_point(field_set:TouchPoint.phase)
}

// float pressure = 5;
inline void TouchPoint::clear_pressure() {
  _impl_.pressure_ = 0;
}
inline float TouchPoint::_internal_pressure() const {
  return _impl_.pressure_;
}
inline float TouchPoint::pressure() const {
  // @@protoc_insertion_point(field_get:TouchPoint.pressure)
  return _internal_pressure();
}
inline void TouchPoint::_internal_set_pressure(float value) {
  
  _impl_.pressure_ = value;
}
inline void TouchPoint::set_pressure(float value) {
  _internal_set_pressure(value);
  // @@protoc_insertion_point(field_set:TouchPoint.pressure)
}

// float size = 6;
inline void TouchPoint::clear_size() {
  _impl_.size_ = 0;
}
inline float TouchPoint::_internal_size() const {
  return _impl_.size_;
}
inline float TouchPoint::size() const {
  // @@protoc_insertion_point(field_get:TouchPoint.size)
  return _internal_size();
}
inline void TouchPoint::_internal_set_size(float value) {
  
  _impl_.size_ = value;
}
inline void TouchPoint::set_size(float value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:TouchPoint.size)
}

// -------------------------------------------------------------------

// TouchEvent

// uint64 timestamp = 1;
inline void TouchEvent::clear_timestamp() {
  _impl_.timestamp_ = uint64_t{0u};
}
inline uint64_t TouchEvent::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline uint64_t TouchEvent::timestamp() const {
  // @@protoc_insertion_point(field_get:TouchEvent.timestamp)
  return _internal_timestamp();
}
inline void TouchEvent::_internal_set_timestamp(uint64_t value) {
  
  _impl_.timestamp_ = value;
}
inline void TouchEvent::set_timestamp(uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:TouchEvent.timestamp)
}

// repeated .TouchPoint points = 2;
inline int TouchEvent::_internal_points_size() const {
  return _impl_.points_.size();
}
inline int TouchEvent::points_size() const {
  return _internal_points_size();
}
inline void TouchEvent::clear_points() {
  _impl_.points_.Clear();
}
inline ::TouchPoint* TouchEvent::mutable_points(int index) {
  // @@protoc_insertion_point(field_mutable:TouchEvent.points)
  return _impl_.points_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TouchPoint >*
TouchEvent::mutable_points() {
  // @@protoc_insertion_point(field_mutable_list:TouchEvent.points)
  return &_impl_.points_;
}
inline const ::TouchPoint& TouchEvent::_internal_points(int index) const {
  return _impl_.points_.Get(index);
}
inline const ::TouchPoint& TouchEvent::points(int index) const {
  // @@protoc_insertion_point(field_get:TouchEvent.points)
  return _internal_points(index);
}
inline ::TouchPoint* TouchEvent::_internal_add_points() {
  return _impl_.points_.Add();
}
inline ::TouchPoint* TouchEvent::add_points() {
  ::TouchPoint* _add = _internal_add_points();
  // @@protoc_insertion_point(field_add:TouchEvent.points)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::TouchPoint >&
TouchEvent::points() const {
  // @@protoc_insertion_point(field_list:TouchEvent.points)
  return _impl_.points_;
}

// -------------------------------------------------------------------

// RendezvousMessage

// .RequestRelay request_relay = 1;
inline bool RendezvousMessage::_internal_has_request_relay() const {
  return union_case() == kRequestRelay;
}
inline bool RendezvousMessage::has_request_relay() const {
  return _internal_has_request_relay();
}
inline void RendezvousMessage::set_has_request_relay() {
  _impl_._oneof_case_[0] = kRequestRelay;
}
inline void RendezvousMessage::clear_request_relay() {
  if (_internal_has_request_relay()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.union_.request_relay_;
    }
    clear_has_union();
  }
}
inline ::RequestRelay* RendezvousMessage::release_request_relay() {
  // @@protoc_insertion_point(field_release:RendezvousMessage.request_relay)
  if (_internal_has_request_relay()) {
    clear_has_union();
    ::RequestRelay* temp = _impl_.union_.request_relay_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.union_.request_relay_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::RequestRelay& RendezvousMessage::_internal_request_relay() const {
  return _internal_has_request_relay()
      ? *_impl_.union_.request_relay_
      : reinterpret_cast< ::RequestRelay&>(::_RequestRelay_default_instance_);
}
inline const ::RequestRelay& RendezvousMessage::request_relay() const {
  // @@protoc_insertion_point(field_get:RendezvousMessage.request_relay)
  return _internal_request_relay();
}
inline ::RequestRelay* RendezvousMessage::unsafe_arena_release_request_relay() {
  // @@protoc_insertion_point(field_unsafe_arena_release:RendezvousMessage.request_relay)
  if (_internal_has_request_relay()) {
    clear_has_union();
    ::RequestRelay* temp = _impl_.union_.request_relay_;
    _impl_.union_.request_relay_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RendezvousMessage::unsafe_arena_set_allocated_request_relay(::RequestRelay* request_relay) {
  clear_union();
  if (request_relay) {
    set_has_request_relay();
    _impl_.union_.request_relay_ = request_relay;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:RendezvousMessage.request_relay)
}
inline ::RequestRelay* RendezvousMessage::_internal_mutable_request_relay() {
  if (!_internal_has_request_relay()) {
    clear_union();
    set_has_request_relay();
    _impl_.union_.request_relay_ = CreateMaybeMessage< ::RequestRelay >(GetArenaForAllocation());
  }
  return _impl_.union_.request_relay_;
}
inline ::RequestRelay* RendezvousMessage::mutable_request_relay() {
  ::RequestRelay* _msg = _internal_mutable_request_relay();
  // @@protoc_insertion_point(field_mutable:RendezvousMessage.request_relay)
  return _msg;
}

// .RegisterPeer register_peer = 2;
inline bool RendezvousMessage::_internal_has_register_peer() const {
  return union_case() == kRegisterPeer;
}
inline bool RendezvousMessage::has_register_peer() const {
  return _internal_has_register_peer();
}
inline void RendezvousMessage::set_has_register_peer() {
  _impl_._oneof_case_[0] = kRegisterPeer;
}
inline void RendezvousMessage::clear_register_peer() {
  if (_internal_has_register_peer()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.union_.register_peer_;
    }
    clear_has_union();
  }
}
inline ::RegisterPeer* RendezvousMessage::release_register_peer() {
  // @@protoc_insertion_point(field_release:RendezvousMessage.register_peer)
  if (_internal_has_register_peer()) {
    clear_has_union();
    ::RegisterPeer* temp = _impl_.union_.register_peer_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.union_.register_peer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::RegisterPeer& RendezvousMessage::_internal_register_peer() const {
  return _internal_has_register_peer()
      ? *_impl_.union_.register_peer_
      : reinterpret_cast< ::RegisterPeer&>(::_RegisterPeer_default_instance_);
}
inline const ::RegisterPeer& RendezvousMessage::register_peer() const {
  // @@protoc_insertion_point(field_get:RendezvousMessage.register_peer)
  return _internal_register_peer();
}
inline ::RegisterPeer* RendezvousMessage::unsafe_arena_release_register_peer() {
  // @@protoc_insertion_point(field_unsafe_arena_release:RendezvousMessage.register_peer)
  if (_internal_has_register_peer()) {
    clear_has_union();
    ::RegisterPeer* temp = _impl_.union_.register_peer_;
    _impl_.union_.register_peer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RendezvousMessage::unsafe_arena_set_allocated_register_peer(::RegisterPeer* register_peer) {
  clear_union();
  if (register_peer) {
    set_has_register_peer();
    _impl_.union_.register_peer_ = register_peer;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:RendezvousMessage.register_peer)
}
inline ::RegisterPeer* RendezvousMessage::_internal_mutable_register_peer() {
  if (!_internal_has_register_peer()) {
    clear_union();
    set_has_register_peer();
    _impl_.union_.register_peer_ = CreateMaybeMessage< ::RegisterPeer >(GetArenaForAllocation());
  }
  return _impl_.union_.register_peer_;
}
inline ::RegisterPeer* RendezvousMessage::mutable_register_peer() {
  ::RegisterPeer* _msg = _internal_mutable_register_peer();
  // @@protoc_insertion_point(field_mutable:RendezvousMessage.register_peer)
  return _msg;
}

// .RegisterPeerResponse register_peer_response = 3;
inline bool RendezvousMessage::_internal_has_register_peer_response() const {
  return union_case() == kRegisterPeerResponse;
}
inline bool RendezvousMessage::has_register_peer_response() const {
  return _internal_has_register_peer_response();
}
inline void RendezvousMessage::set_has_register_peer_response() {
  _impl_._oneof_case_[0] = kRegisterPeerResponse;
}
inline void RendezvousMessage::clear_register_peer_response() {
  if (_internal_has_register_peer_response()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.union_.register_peer_response_;
    }
    clear_has_union();
  }
}
inline ::RegisterPeerResponse* RendezvousMessage::release_register_peer_response() {
  // @@protoc_insertion_point(field_release:RendezvousMessage.register_peer_response)
  if (_internal_has_register_peer_response()) {
    clear_has_union();
    ::RegisterPeerResponse* temp = _impl_.union_.register_peer_response_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.union_.register_peer_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::RegisterPeerResponse& RendezvousMessage::_internal_register_peer_response() const {
  return _internal_has_register_peer_response()
      ? *_impl_.union_.register_peer_response_
      : reinterpret_cast< ::RegisterPeerResponse&>(::_RegisterPeerResponse_default_instance_);
}
inline const ::RegisterPeerResponse& RendezvousMessage::register_peer_response() const {
  // @@protoc_insertion_point(field_get:RendezvousMessage.register_peer_response)
  return _internal_register_peer_response();
}
inline ::RegisterPeerResponse* RendezvousMessage::unsafe_arena_release_register_peer_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:RendezvousMessage.register_peer_response)
  if (_internal_has_register_peer_response()) {
    clear_has_union();
    ::RegisterPeerResponse* temp = _impl_.union_.register_peer_response_;
    _impl_.union_.register_peer_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RendezvousMessage::unsafe_arena_set_allocated_register_peer_response(::RegisterPeerResponse* register_peer_response) {
  clear_union();
  if (register_peer_response) {
    set_has_register_peer_response();
    _impl_.union_.register_peer_response_ = register_peer_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:RendezvousMessage.register_peer_response)
}
inline ::RegisterPeerResponse* RendezvousMessage::_internal_mutable_register_peer_response() {
  if (!_internal_has_register_peer_response()) {
    clear_union();
    set_has_register_peer_response();
    _impl_.union_.register_peer_response_ = CreateMaybeMessage< ::RegisterPeerResponse >(GetArenaForAllocation());
  }
  return _impl_.union_.register_peer_response_;
}
inline ::RegisterPeerResponse* RendezvousMessage::mutable_register_peer_response() {
  ::RegisterPeerResponse* _msg = _internal_mutable_register_peer_response();
  // @@protoc_insertion_point(field_mutable:RendezvousMessage.register_peer_response)
  return _msg;
}

// .PunchHoleRequest punch_hole_request = 4;
inline bool RendezvousMessage::_internal_has_punch_hole_request() const {
  return union_case() == kPunchHoleRequest;
}
inline bool RendezvousMessage::has_punch_hole_request() const {
  return _internal_has_punch_hole_request();
}
inline void RendezvousMessage::set_has_punch_hole_request() {
  _impl_._oneof_case_[0] = kPunchHoleRequest;
}
inline void RendezvousMessage::clear_punch_hole_request() {
  if (_internal_has_punch_hole_request()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.union_.punch_hole_request_;
    }
    clear_has_union();
  }
}
inline ::PunchHoleRequest* RendezvousMessage::release_punch_hole_request() {
  // @@protoc_insertion_point(field_release:RendezvousMessage.punch_hole_request)
  if (_internal_has_punch_hole_request()) {
    clear_has_union();
    ::PunchHoleRequest* temp = _impl_.union_.punch_hole_request_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.union_.punch_hole_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::PunchHoleRequest& RendezvousMessage::_internal_punch_hole_request() const {
  return _internal_has_punch_hole_request()
      ? *_impl_.union_.punch_hole_request_
      : reinterpret_cast< ::PunchHoleRequest&>(::_PunchHoleRequest_default_instance_);
}
inline const ::PunchHoleRequest& RendezvousMessage::punch_hole_request() const {
  // @@protoc_insertion_point(field_get:RendezvousMessage.punch_hole_request)
  return _internal_punch_hole_request();
}
inline ::PunchHoleRequest* RendezvousMessage::unsafe_arena_release_punch_hole_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:RendezvousMessage.punch_hole_request)
  if (_internal_has_punch_hole_request()) {
    clear_has_union();
    ::PunchHoleRequest* temp = _impl_.union_.punch_hole_request_;
    _impl_.union_.punch_hole_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RendezvousMessage::unsafe_arena_set_allocated_punch_hole_request(::PunchHoleRequest* punch_hole_request) {
  clear_union();
  if (punch_hole_request) {
    set_has_punch_hole_request();
    _impl_.union_.punch_hole_request_ = punch_hole_request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:RendezvousMessage.punch_hole_request)
}
inline ::PunchHoleRequest* RendezvousMessage::_internal_mutable_punch_hole_request() {
  if (!_internal_has_punch_hole_request()) {
    clear_union();
    set_has_punch_hole_request();
    _impl_.union_.punch_hole_request_ = CreateMaybeMessage< ::PunchHoleRequest >(GetArenaForAllocation());
  }
  return _impl_.union_.punch_hole_request_;
}
inline ::PunchHoleRequest* RendezvousMessage::mutable_punch_hole_request() {
  ::PunchHoleRequest* _msg = _internal_mutable_punch_hole_request();
  // @@protoc_insertion_point(field_mutable:RendezvousMessage.punch_hole_request)
  return _msg;
}

// .PunchHoleResponse punch_hole_response = 5;
inline bool RendezvousMessage::_internal_has_punch_hole_response() const {
  return union_case() == kPunchHoleResponse;
}
inline bool RendezvousMessage::has_punch_hole_response() const {
  return _internal_has_punch_hole_response();
}
inline void RendezvousMessage::set_has_punch_hole_response() {
  _impl_._oneof_case_[0] = kPunchHoleResponse;
}
inline void RendezvousMessage::clear_punch_hole_response() {
  if (_internal_has_punch_hole_response()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.union_.punch_hole_response_;
    }
    clear_has_union();
  }
}
inline ::PunchHoleResponse* RendezvousMessage::release_punch_hole_response() {
  // @@protoc_insertion_point(field_release:RendezvousMessage.punch_hole_response)
  if (_internal_has_punch_hole_response()) {
    clear_has_union();
    ::PunchHoleResponse* temp = _impl_.union_.punch_hole_response_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.union_.punch_hole_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::PunchHoleResponse& RendezvousMessage::_internal_punch_hole_response() const {
  return _internal_has_punch_hole_response()
      ? *_impl_.union_.punch_hole_response_
      : reinterpret_cast< ::PunchHoleResponse&>(::_PunchHoleResponse_default_instance_);
}
inline const ::PunchHoleResponse& RendezvousMessage::punch_hole_response() const {
  // @@protoc_insertion_point(field_get:RendezvousMessage.punch_hole_response)
  return _internal_punch_hole_response();
}
inline ::PunchHoleResponse* RendezvousMessage::unsafe_arena_release_punch_hole_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:RendezvousMessage.punch_hole_response)
  if (_internal_has_punch_hole_response()) {
    clear_has_union();
    ::PunchHoleResponse* temp = _impl_.union_.punch_hole_response_;
    _impl_.union_.punch_hole_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RendezvousMessage::unsafe_arena_set_allocated_punch_hole_response(::PunchHoleResponse* punch_hole_response) {
  clear_union();
  if (punch_hole_response) {
    set_has_punch_hole_response();
    _impl_.union_.punch_hole_response_ = punch_hole_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:RendezvousMessage.punch_hole_response)
}
inline ::PunchHoleResponse* RendezvousMessage::_internal_mutable_punch_hole_response() {
  if (!_internal_has_punch_hole_response()) {
    clear_union();
    set_has_punch_hole_response();
    _impl_.union_.punch_hole_response_ = CreateMaybeMessage< ::PunchHoleResponse >(GetArenaForAllocation());
  }
  return _impl_.union_.punch_hole_response_;
}
inline ::PunchHoleResponse* RendezvousMessage::mutable_punch_hole_response() {
  ::PunchHoleResponse* _msg = _internal_mutable_punch_hole_response();
  // @@protoc_insertion_point(field_mutable:RendezvousMessage.punch_hole_response)
  return _msg;
}

// .Heartbeat heartbeat = 6;
inline bool RendezvousMessage::_internal_has_heartbeat() const {
  return union_case() == kHeartbeat;
}
inline bool RendezvousMessage::has_heartbeat() const {
  return _internal_has_heartbeat();
}
inline void RendezvousMessage::set_has_heartbeat() {
  _impl_._oneof_case_[0] = kHeartbeat;
}
inline void RendezvousMessage::clear_heartbeat() {
  if (_internal_has_heartbeat()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.union_.heartbeat_;
    }
    clear_has_union();
  }
}
inline ::Heartbeat* RendezvousMessage::release_heartbeat() {
  // @@protoc_insertion_point(field_release:RendezvousMessage.heartbeat)
  if (_internal_has_heartbeat()) {
    clear_has_union();
    ::Heartbeat* temp = _impl_.union_.heartbeat_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.union_.heartbeat_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Heartbeat& RendezvousMessage::_internal_heartbeat() const {
  return _internal_has_heartbeat()
      ? *_impl_.union_.heartbeat_
      : reinterpret_cast< ::Heartbeat&>(::_Heartbeat_default_instance_);
}
inline const ::Heartbeat& RendezvousMessage::heartbeat() const {
  // @@protoc_insertion_point(field_get:RendezvousMessage.heartbeat)
  return _internal_heartbeat();
}
inline ::Heartbeat* RendezvousMessage::unsafe_arena_release_heartbeat() {
  // @@protoc_insertion_point(field_unsafe_arena_release:RendezvousMessage.heartbeat)
  if (_internal_has_heartbeat()) {
    clear_has_union();
    ::Heartbeat* temp = _impl_.union_.heartbeat_;
    _impl_.union_.heartbeat_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RendezvousMessage::unsafe_arena_set_allocated_heartbeat(::Heartbeat* heartbeat) {
  clear_union();
  if (heartbeat) {
    set_has_heartbeat();
    _impl_.union_.heartbeat_ = heartbeat;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:RendezvousMessage.heartbeat)
}
inline ::Heartbeat* RendezvousMessage::_internal_mutable_heartbeat() {
  if (!_internal_has_heartbeat()) {
    clear_union();
    set_has_heartbeat();
    _impl_.union_.heartbeat_ = CreateMaybeMessage< ::Heartbeat >(GetArenaForAllocation());
  }
  return _impl_.union_.heartbeat_;
}
inline ::Heartbeat* RendezvousMessage::mutable_heartbeat() {
  ::Heartbeat* _msg = _internal_mutable_heartbeat();
  // @@protoc_insertion_point(field_mutable:RendezvousMessage.heartbeat)
  return _msg;
}

// .PunchHole punch_hole = 7;
inline bool RendezvousMessage::_internal_has_punch_hole() const {
  return union_case() == kPunchHole;
}
inline bool RendezvousMessage::has_punch_hole() const {
  return _internal_has_punch_hole();
}
inline void RendezvousMessage::set_has_punch_hole() {
  _impl_._oneof_case_[0] = kPunchHole;
}
inline void RendezvousMessage::clear_punch_hole() {
  if (_internal_has_punch_hole()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.union_.punch_hole_;
    }
    clear_has_union();
  }
}
inline ::PunchHole* RendezvousMessage::release_punch_hole() {
  // @@protoc_insertion_point(field_release:RendezvousMessage.punch_hole)
  if (_internal_has_punch_hole()) {
    clear_has_union();
    ::PunchHole* temp = _impl_.union_.punch_hole_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.union_.punch_hole_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::PunchHole& RendezvousMessage::_internal_punch_hole() const {
  return _internal_has_punch_hole()
      ? *_impl_.union_.punch_hole_
      : reinterpret_cast< ::PunchHole&>(::_PunchHole_default_instance_);
}
inline const ::PunchHole& RendezvousMessage::punch_hole() const {
  // @@protoc_insertion_point(field_get:RendezvousMessage.punch_hole)
  return _internal_punch_hole();
}
inline ::PunchHole* RendezvousMessage::unsafe_arena_release_punch_hole() {
  // @@protoc_insertion_point(field_unsafe_arena_release:RendezvousMessage.punch_hole)
  if (_internal_has_punch_hole()) {
    clear_has_union();
    ::PunchHole* temp = _impl_.union_.punch_hole_;
    _impl_.union_.punch_hole_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RendezvousMessage::unsafe_arena_set_allocated_punch_hole(::PunchHole* punch_hole) {
  clear_union();
  if (punch_hole) {
    set_has_punch_hole();
    _impl_.union_.punch_hole_ = punch_hole;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:RendezvousMessage.punch_hole)
}
inline ::PunchHole* RendezvousMessage::_internal_mutable_punch_hole() {
  if (!_internal_has_punch_hole()) {
    clear_union();
    set_has_punch_hole();
    _impl_.union_.punch_hole_ = CreateMaybeMessage< ::PunchHole >(GetArenaForAllocation());
  }
  return _impl_.union_.punch_hole_;
}
inline ::PunchHole* RendezvousMessage::mutable_punch_hole() {
  ::PunchHole* _msg = _internal_mutable_punch_hole();
  // @@protoc_insertion_point(field_mutable:RendezvousMessage.punch_hole)
  return _msg;
}

// .PunchHoleSent punch_hole_sent = 8;
inline bool RendezvousMessage::_internal_has_punch_hole_sent() const {
  return union_case() == kPunchHoleSent;
}
inline bool RendezvousMessage::has_punch_hole_sent() const {
  return _internal_has_punch_hole_sent();
}
inline void RendezvousMessage::set_has_punch_hole_sent() {
  _impl_._oneof_case_[0] = kPunchHoleSent;
}
inline void RendezvousMessage::clear_punch_hole_sent() {
  if (_internal_has_punch_hole_sent()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.union_.punch_hole_sent_;
    }
    clear_has_union();
  }
}
inline ::PunchHoleSent* RendezvousMessage::release_punch_hole_sent() {
  // @@protoc_insertion_point(field_release:RendezvousMessage.punch_hole_sent)
  if (_internal_has_punch_hole_sent()) {
    clear_has_union();
    ::PunchHoleSent* temp = _impl_.union_.punch_hole_sent_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.union_.punch_hole_sent_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::PunchHoleSent& RendezvousMessage::_internal_punch_hole_sent() const {
  return _internal_has_punch_hole_sent()
      ? *_impl_.union_.punch_hole_sent_
      : reinterpret_cast< ::PunchHoleSent&>(::_PunchHoleSent_default_instance_);
}
inline const ::PunchHoleSent& RendezvousMessage::punch_hole_sent() const {
  // @@protoc_insertion_point(field_get:RendezvousMessage.punch_hole_sent)
  return _internal_punch_hole_sent();
}
inline ::PunchHoleSent* RendezvousMessage::unsafe_arena_release_punch_hole_sent() {
  // @@protoc_insertion_point(field_unsafe_arena_release:RendezvousMessage.punch_hole_sent)
  if (_internal_has_punch_hole_sent()) {
    clear_has_union();
    ::PunchHoleSent* temp = _impl_.union_.punch_hole_sent_;
    _impl_.union_.punch_hole_sent_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RendezvousMessage::unsafe_arena_set_allocated_punch_hole_sent(::PunchHoleSent* punch_hole_sent) {
  clear_union();
  if (punch_hole_sent) {
    set_has_punch_hole_sent();
    _impl_.union_.punch_hole_sent_ = punch_hole_sent;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:RendezvousMessage.punch_hole_sent)
}
inline ::PunchHoleSent* RendezvousMessage::_internal_mutable_punch_hole_sent() {
  if (!_internal_has_punch_hole_sent()) {
    clear_union();
    set_has_punch_hole_sent();
    _impl_.union_.punch_hole_sent_ = CreateMaybeMessage< ::PunchHoleSent >(GetArenaForAllocation());
  }
  return _impl_.union_.punch_hole_sent_;
}
inline ::PunchHoleSent* RendezvousMessage::mutable_punch_hole_sent() {
  ::PunchHoleSent* _msg = _internal_mutable_punch_hole_sent();
  // @@protoc_insertion_point(field_mutable:RendezvousMessage.punch_hole_sent)
  return _msg;
}

// .InpuVideoFrame inpuVideoFrame = 9;
inline bool RendezvousMessage::_internal_has_inpuvideoframe() const {
  return union_case() == kInpuVideoFrame;
}
inline bool RendezvousMessage::has_inpuvideoframe() const {
  return _internal_has_inpuvideoframe();
}
inline void RendezvousMessage::set_has_inpuvideoframe() {
  _impl_._oneof_case_[0] = kInpuVideoFrame;
}
inline void RendezvousMessage::clear_inpuvideoframe() {
  if (_internal_has_inpuvideoframe()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.union_.inpuvideoframe_;
    }
    clear_has_union();
  }
}
inline ::InpuVideoFrame* RendezvousMessage::release_inpuvideoframe() {
  // @@protoc_insertion_point(field_release:RendezvousMessage.inpuVideoFrame)
  if (_internal_has_inpuvideoframe()) {
    clear_has_union();
    ::InpuVideoFrame* temp = _impl_.union_.inpuvideoframe_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.union_.inpuvideoframe_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::InpuVideoFrame& RendezvousMessage::_internal_inpuvideoframe() const {
  return _internal_has_inpuvideoframe()
      ? *_impl_.union_.inpuvideoframe_
      : reinterpret_cast< ::InpuVideoFrame&>(::_InpuVideoFrame_default_instance_);
}
inline const ::InpuVideoFrame& RendezvousMessage::inpuvideoframe() const {
  // @@protoc_insertion_point(field_get:RendezvousMessage.inpuVideoFrame)
  return _internal_inpuvideoframe();
}
inline ::InpuVideoFrame* RendezvousMessage::unsafe_arena_release_inpuvideoframe() {
  // @@protoc_insertion_point(field_unsafe_arena_release:RendezvousMessage.inpuVideoFrame)
  if (_internal_has_inpuvideoframe()) {
    clear_has_union();
    ::InpuVideoFrame* temp = _impl_.union_.inpuvideoframe_;
    _impl_.union_.inpuvideoframe_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RendezvousMessage::unsafe_arena_set_allocated_inpuvideoframe(::InpuVideoFrame* inpuvideoframe) {
  clear_union();
  if (inpuvideoframe) {
    set_has_inpuvideoframe();
    _impl_.union_.inpuvideoframe_ = inpuvideoframe;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:RendezvousMessage.inpuVideoFrame)
}
inline ::InpuVideoFrame* RendezvousMessage::_internal_mutable_inpuvideoframe() {
  if (!_internal_has_inpuvideoframe()) {
    clear_union();
    set_has_inpuvideoframe();
    _impl_.union_.inpuvideoframe_ = CreateMaybeMessage< ::InpuVideoFrame >(GetArenaForAllocation());
  }
  return _impl_.union_.inpuvideoframe_;
}
inline ::InpuVideoFrame* RendezvousMessage::mutable_inpuvideoframe() {
  ::InpuVideoFrame* _msg = _internal_mutable_inpuvideoframe();
  // @@protoc_insertion_point(field_mutable:RendezvousMessage.inpuVideoFrame)
  return _msg;
}

// .InputControlEvent inputControlEvent = 10;
inline bool RendezvousMessage::_internal_has_inputcontrolevent() const {
  return union_case() == kInputControlEvent;
}
inline bool RendezvousMessage::has_inputcontrolevent() const {
  return _internal_has_inputcontrolevent();
}
inline void RendezvousMessage::set_has_inputcontrolevent() {
  _impl_._oneof_case_[0] = kInputControlEvent;
}
inline void RendezvousMessage::clear_inputcontrolevent() {
  if (_internal_has_inputcontrolevent()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.union_.inputcontrolevent_;
    }
    clear_has_union();
  }
}
inline ::InputControlEvent* RendezvousMessage::release_inputcontrolevent() {
  // @@protoc_insertion_point(field_release:RendezvousMessage.inputControlEvent)
  if (_internal_has_inputcontrolevent()) {
    clear_has_union();
    ::InputControlEvent* temp = _impl_.union_.inputcontrolevent_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.union_.inputcontrolevent_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::InputControlEvent& RendezvousMessage::_internal_inputcontrolevent() const {
  return _internal_has_inputcontrolevent()
      ? *_impl_.union_.inputcontrolevent_
      : reinterpret_cast< ::InputControlEvent&>(::_InputControlEvent_default_instance_);
}
inline const ::InputControlEvent& RendezvousMessage::inputcontrolevent() const {
  // @@protoc_insertion_point(field_get:RendezvousMessage.inputControlEvent)
  return _internal_inputcontrolevent();
}
inline ::InputControlEvent* RendezvousMessage::unsafe_arena_release_inputcontrolevent() {
  // @@protoc_insertion_point(field_unsafe_arena_release:RendezvousMessage.inputControlEvent)
  if (_internal_has_inputcontrolevent()) {
    clear_has_union();
    ::InputControlEvent* temp = _impl_.union_.inputcontrolevent_;
    _impl_.union_.inputcontrolevent_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RendezvousMessage::unsafe_arena_set_allocated_inputcontrolevent(::InputControlEvent* inputcontrolevent) {
  clear_union();
  if (inputcontrolevent) {
    set_has_inputcontrolevent();
    _impl_.union_.inputcontrolevent_ = inputcontrolevent;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:RendezvousMessage.inputControlEvent)
}
inline ::InputControlEvent* RendezvousMessage::_internal_mutable_inputcontrolevent() {
  if (!_internal_has_inputcontrolevent()) {
    clear_union();
    set_has_inputcontrolevent();
    _impl_.union_.inputcontrolevent_ = CreateMaybeMessage< ::InputControlEvent >(GetArenaForAllocation());
  }
  return _impl_.union_.inputcontrolevent_;
}
inline ::InputControlEvent* RendezvousMessage::mutable_inputcontrolevent() {
  ::InputControlEvent* _msg = _internal_mutable_inputcontrolevent();
  // @@protoc_insertion_point(field_mutable:RendezvousMessage.inputControlEvent)
  return _msg;
}

// .ClipboardEvent clipboardEvent = 11;
inline bool RendezvousMessage::_internal_has_clipboardevent() const {
  return union_case() == kClipboardEvent;
}
inline bool RendezvousMessage::has_clipboardevent() const {
  return _internal_has_clipboardevent();
}
inline void RendezvousMessage::set_has_clipboardevent() {
  _impl_._oneof_case_[0] = kClipboardEvent;
}
inline void RendezvousMessage::clear_clipboardevent() {
  if (_internal_has_clipboardevent()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.union_.clipboardevent_;
    }
    clear_has_union();
  }
}
inline ::ClipboardEvent* RendezvousMessage::release_clipboardevent() {
  // @@protoc_insertion_point(field_release:RendezvousMessage.clipboardEvent)
  if (_internal_has_clipboardevent()) {
    clear_has_union();
    ::ClipboardEvent* temp = _impl_.union_.clipboardevent_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.union_.clipboardevent_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ClipboardEvent& RendezvousMessage::_internal_clipboardevent() const {
  return _internal_has_clipboardevent()
      ? *_impl_.union_.clipboardevent_
      : reinterpret_cast< ::ClipboardEvent&>(::_ClipboardEvent_default_instance_);
}
inline const ::ClipboardEvent& RendezvousMessage::clipboardevent() const {
  // @@protoc_insertion_point(field_get:RendezvousMessage.clipboardEvent)
  return _internal_clipboardevent();
}
inline ::ClipboardEvent* RendezvousMessage::unsafe_arena_release_clipboardevent() {
  // @@protoc_insertion_point(field_unsafe_arena_release:RendezvousMessage.clipboardEvent)
  if (_internal_has_clipboardevent()) {
    clear_has_union();
    ::ClipboardEvent* temp = _impl_.union_.clipboardevent_;
    _impl_.union_.clipboardevent_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RendezvousMessage::unsafe_arena_set_allocated_clipboardevent(::ClipboardEvent* clipboardevent) {
  clear_union();
  if (clipboardevent) {
    set_has_clipboardevent();
    _impl_.union_.clipboardevent_ = clipboardevent;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:RendezvousMessage.clipboardEvent)
}
inline ::ClipboardEvent* RendezvousMessage::_internal_mutable_clipboardevent() {
  if (!_internal_has_clipboardevent()) {
    clear_union();
    set_has_clipboardevent();
    _impl_.union_.clipboardevent_ = CreateMaybeMessage< ::ClipboardEvent >(GetArenaForAllocation());
  }
  return _impl_.union_.clipboardevent_;
}
inline ::ClipboardEvent* RendezvousMessage::mutable_clipboardevent() {
  ::ClipboardEvent* _msg = _internal_mutable_clipboardevent();
  // @@protoc_insertion_point(field_mutable:RendezvousMessage.clipboardEvent)
  return _msg;
}

inline bool RendezvousMessage::has_union() const {
  return union_case() != UNION_NOT_SET;
}
inline void RendezvousMessage::clear_has_union() {
  _impl_._oneof_case_[0] = UNION_NOT_SET;
}
inline RendezvousMessage::UnionCase RendezvousMessage::union_case() const {
  return RendezvousMessage::UnionCase(_impl_._oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::RequestRelay_DeskRole> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::RequestRelay_DeskRole>() {
  return ::RequestRelay_DeskRole_descriptor();
}
template <> struct is_proto_enum< ::TouchPoint_TouchPhase> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::TouchPoint_TouchPhase>() {
  return ::TouchPoint_TouchPhase_descriptor();
}
template <> struct is_proto_enum< ::Result> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Result>() {
  return ::Result_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_rendezvous_2eproto
